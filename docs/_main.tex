% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmainfont[]{Arial}
  \setmonofont[]{Courier New}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={STAT 107 Outline of Class Notes},
  pdfauthor={Rebecca Kurtz-Garcia},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\title{STAT 107 Outline of Class Notes}
\author{Rebecca Kurtz-Garcia}
\date{2022-09-21}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{welcome}{%
\chapter*{Welcome}\label{welcome}}
\addcontentsline{toc}{chapter}{Welcome}

Welcome to STAT 107! This document will contain and outline of the course notes throughout the quarter. Please see the course website for an approximate schedule. In each of the chapters there will be a list of links, resources, and videos for learning more about an individual topic. This document will be updated constantly, be sure to check here for periodic updates. In addition, this document does not serve as a substitute for in class instruction, but more as a guide for the general content we discuss. Students are still expected to attend every lecture.

\hypertarget{introduction-to-r}{%
\chapter{Introduction to R}\label{introduction-to-r}}

\href{https://drive.google.com/drive/folders/1wqLcBREQ3wahLH6Z7tAZEjxz11cFkgN2?usp=sharing}{Videos for this chapter are here!}

In this chapter we introduce R and RStudio, which you'll be using throughout this course to learn how to analyze real data and come to informed conclusions. To straighten out which is which: R is the name of the programming language itself, and RStudio is a convenient interface for using R.

As the course progresses, you are encouraged to explore beyond what we discuss; a willingness to experiment will make you a much better scientist and researcher. Before we get to that stage, however, you need to build some competence in R. We begin with some of the fundamental building blocks of R and Rstudio: the interface, data types, variables, importing data, and plotting data.

R is widely used by the scientific community as a no-cost alternative to expensive commercial software packages like SPSS and MATLAB. It is both a statistical software analysis system and a programming environment for developing scientific applications. Scientists routinely make available for free R programs they have developed that might be of use to others. Hundreds of packages can be downloaded for all types of scientific computing applications. This chapter was written by the help of \citet{Desharnais2020}.

\hypertarget{download-and-install-r-and-rstudio}{%
\section{Download and Install R and Rstudio}\label{download-and-install-r-and-rstudio}}

To get started, you need to download both the R and Rstudio software. Both are available for free and there are versions for \emph{Linux}, \emph{Mac OS X}, and \emph{Windows}. It is suggested that you download R first and then Rstudio. R can be used without RStudio, but RStudio provides a convenient user interface and programming environment for R.

The details for downloading and installing these software packages varies depending on your computer and operating system. You may need permission to install the software on your computer. The links below provide access to a mirror archive at UCLA for downloading R and the developer's site for downloading RStudio.

\begin{itemize}
\item
  To download R, go to the url \url{https://ftp.osuosl.org/pub/cran}. Choose the binary distribution appropriate for your computer.

  \begin{itemize}
  \tightlist
  \item
    \emph{Windows} users will want to click on the link to ``Download R for Windows'' and choose ``install R for the first time,'' then ``Download R 3.5.2 for Windows.''
  \item
    \emph{Mac OS} users will want to click ``Download R for (Mac) OS X.'' Download the install package for version R-3.5.2 If you are using Mac OS X 10.9-10.10, install version R-3.3.3. If you are using OS X 10.6-10.8, install version R-3.2.1.
  \item
    \emph{Linux} users will want to click on the link to ``Download R for Linux.'' You will need to choose the version of Linux that corresponds to your installation. Versions are available for Debian, RedHat, SUSE, and Ubuntu.
  \end{itemize}
\item
  For RStudio, use the url \url{https://www.rstudio.com/products/rstudio/download/}. Choose the binary distribution appropriate for your computer. Installers are provided for a variety of platforms.
\item
  For additional help please see this video: \href{https://ucr.yuja.com/V/Video?v=2365045\&node=8476457\&a=437885577\&autoplay=1}{Getting Started 1 \textbar{} How to Download and Install RStudio}
\end{itemize}

\hypertarget{the-rstudio-interface}{%
\section{\texorpdfstring{The \textbf{RStudio} Interface}{The RStudio Interface}}\label{the-rstudio-interface}}

We will begin by looking at the RStudio software interface. The RStudio program is referred to the window, and each section in the interface is a pane.

\includegraphics[width=49.78in]{images/rstudio}

Launch RStudio. You will see a window that looks like the figure above. The four panes of the window are described as follows:

\begin{itemize}
\item
  The pane in the bottom left is the \textbf{R Command Console}, this is where you type R commands for immediate execution.
\item
  The pane in the upper left portion of the window is an area for editing R source code for scripts and functions and for viewing R data frame objects. New tabs will be added as new R code files and data objects are opened.
\item
  The pane in the upper right portion of the window is an area for browsing the variables in the R workspace \textbf{environment} and the R command line history.
\item
  The pane in the lower right portion of the window has several tabs. The \emph{Files} tab is an area for browsing the files in the current working directory. The \emph{Plot} tab is for viewing graphics produced using R commands. The \emph{Packages} tab lists the R packages available. Other packages can be loaded. The \emph{Help} tab provides access to the R documentation. The \emph{Viewer} tab is for viewing local web content in the temporary session directory (not files on the web).
\end{itemize}

\hypertarget{bottom-left-pane}{%
\subsection*{Bottom Left Pane}\label{bottom-left-pane}}
\addcontentsline{toc}{subsection}{Bottom Left Pane}

Let's begin with the Console. This is where you type R commands for immediate execution. Click in the Command Console, ``\textgreater{}'' symbol is the system prompt. You should see a blinking cursor that tells you the console is the current focus of keyboard input. Type:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

The result tells you that the line begins with the first (and only) element of the result which is the number 3. You can also execute R's built-in functions (or functions you add). Type the following command.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{exp}\NormalTok{(pi)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23.14069
\end{verbatim}

In R, ``pi'' is a special constant to represent the number and ``exp'' is the exponential function. The result tells you that the first (and only) element of the result is the number \(e^{\pi}=\) 23.14069.

\hypertarget{bottom-right-pane}{%
\subsection*{Bottom Right Pane}\label{bottom-right-pane}}
\addcontentsline{toc}{subsection}{Bottom Right Pane}

Now let's look at the \emph{Files} tab of the notebook at the lower right of the window. Every R session has a working directory where R looks for and saves files. It is a good practice to create a different directory for every project and make that directory the working directory. For example, let's make a new directory called \emph{MyDirectory}. (You can chose another name if you wish).

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Click on the \textbf{Files} tab of the notebook. You should see a listing of files in your default working directory.
\item
  Click on the small button with an ellipsis image on the right side of the file path above the directory listing.
\item
  Navigate to the folder where you want to create the new directory and click the \textbf{OK} button.
\item
  Click on the \textbf{New Folder} button just below the Files tab (see right).
\item
  Type \textbf{MyDirectory} in the panel that opens click on the folder in the Notebook.
\item
  Click the \textbf{More} button to the right of the New Folder button and select the menu option \textbf{Set as Working Directory}. This new folder is now the working directory for the current R session. This menu option is a short cut for a command that was automatically entered into the R console.
\end{enumerate}

\hypertarget{top-right-pane}{%
\subsection*{Top Right Pane}\label{top-right-pane}}
\addcontentsline{toc}{subsection}{Top Right Pane}

Next we will look at the \emph{R environment}, also called the \emph{R workspace}. This is where you can see the names and other information on the variables that were created during your R session and are available for use in other commands.

In the R console type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\FloatTok{29.325}
\NormalTok{b <-}\StringTok{ }\KeywordTok{log}\NormalTok{(a)}
\NormalTok{c <-}\StringTok{ }\NormalTok{a}\OperatorTok{/}\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Look at the Environment pane. The variables \texttt{a}, \texttt{b}, and \texttt{c} are now part of your R work space. You can reuse those variables as part of other commands.

In the R console type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v <-}\StringTok{ }\KeywordTok{c}\NormalTok{(a, b, c)}
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 29.325000  3.378440  8.680041
\end{verbatim}

The variable \texttt{v} is a vector created using the \emph{concatenate} function \texttt{c()}. (The concatenate should not be confused with the variable c that was created earlier. Functions are always followed by parentheses that contain the function arguments). This function combines its arguments into a vector or list. Look at the Environment panel. The text \texttt{num\ {[}1:3{]}} tells us that the variable \texttt{v} is a vector with elements \texttt{v{[}1{]}}, \texttt{v{[}2{]}}, and \texttt{v{[}3{]}}.

\hypertarget{top-left-pane}{%
\subsection*{Top Left Pane}\label{top-left-pane}}
\addcontentsline{toc}{subsection}{Top Left Pane}

Now let's look at the R viewer notebook. This panel can be used to data which are data frame objects or \emph{matrix objects} in R.

We will begin by taking advantage of a data frame object that was built into R for demonstration purposes. We will copy it into a data frame object. In the R console, type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\NormalTok{mtcars}
\end{Highlighting}
\end{Shaded}

Let's view the data. On the right side of the entry for the \texttt{df} object is a button we can use to view the entries of the data frame. Click on the View Button.

If your look in the notebook area in the upper left portion of the window, you can see a spreadsheet-like view of the data. This is for viewing only; you cannot edit the data. Use the scroll bars to view the data entries.

You can also list the data in the console by typing the name of the data fame object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
## Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
## Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
## Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
## Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
## AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
## Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
## Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
## Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
## Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

The columns are labeled with the names of the variables and the rows are labeled with the names of each car. Each row represents the data values for one car; that is, each row is one observation.

\hypertarget{comments}{%
\section{Comments}\label{comments}}

Often times we will want to add a comment to our script document so we can remember special aspects later, and make the code easier to read and modify in the future. To add a comment start the comment with a \texttt{\#} symbol. This will make the remaining characters in a line a comment and R will not try to compile these lines. Go to the script document and type the following. Highlight what you have typed and press ``Run''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This is a comment}
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}  \CommentTok{# Comments can also start in the middle of a line. }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\hypertarget{operators}{%
\section{Operators}\label{operators}}

An operator is a symbol that tells the compiler to preform a specific task. There are several types of operators, some preform mathematical tasks, logical checks, and create new objects. We will review a few of the basic operators here. We will continue to discuss and introduce operators throughout this document.

\hypertarget{arithmetic-operators}{%
\subsection*{Arithmetic Operators}\label{arithmetic-operators}}
\addcontentsline{toc}{subsection}{Arithmetic Operators}

R was designed for statistical applications and as a necessity it needs to preform mathematical operations efficiently and effectively. The first operators we discuss are a few of the basic arithmetic operations. These are operations similar to that of a calculator.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Addition}
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Subtraction}
\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Multiplication}
\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Division}
\DecValTok{2}\OperatorTok{/}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6666667
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Exponent}
\DecValTok{2}\OperatorTok{^}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\hypertarget{relational-operators}{%
\subsection*{Relational Operators}\label{relational-operators}}
\addcontentsline{toc}{subsection}{Relational Operators}

Relational operators are used to compare two values. When using a relational operation R will return either \texttt{TRUE} or \texttt{FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Less than}
\DecValTok{2} \OperatorTok{<}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Greater than}
\DecValTok{2} \OperatorTok{>}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Less than or equal to}
\DecValTok{2} \OperatorTok{<=}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Greater than or equal to}
\DecValTok{2} \OperatorTok{>=}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Not equal to}
\DecValTok{2} \OperatorTok{!=}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Equal to}
\DecValTok{2} \OperatorTok{==}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

We can use all the same operators above if our object contains more than one element. This will preform the above comparisons element by element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 29.325000  3.378440  8.680041
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{>}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE
\end{verbatim}

If we have two vectors of an unequal length then the checks will be preformed element-by-element but the values in the shorter vector will be \emph{recycled}, or \emph{repeated}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{v }\OperatorTok{>}\StringTok{ }\NormalTok{w}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in v > w: longer object length is not a multiple of shorter object
## length
\end{verbatim}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE
\end{verbatim}

R evaluated the first and third element of \texttt{v} and compared it to the first element of \texttt{w}, and the second element of \texttt{v} to the second element of \texttt{w}. In this case, R returned a \emph{warning} alerting you that it recycled elements. However, R will not always give a warning.

\hypertarget{logical-operators}{%
\subsection*{Logical operators}\label{logical-operators}}
\addcontentsline{toc}{subsection}{Logical operators}

Logical operators are similar to relational operators. They are used to check ``AND'' and ``OR'' events. We have the \texttt{\&} symbol which returns \texttt{TRUE} only if BOTH conditions are true. We also have the \texttt{\textbar{}} symbol which returns \texttt{TRUE} if EITHER condition is true.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Check if both operations are true.}
\NormalTok{(}\DecValTok{2} \OperatorTok{<}\StringTok{ }\DecValTok{3}\NormalTok{) }\OperatorTok{&}\StringTok{ }\NormalTok{(}\DecValTok{5} \OperatorTok{<}\StringTok{ }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Check if either operation is true.}
\NormalTok{(}\DecValTok{2} \OperatorTok{<}\StringTok{ }\DecValTok{3}\NormalTok{) }\OperatorTok{|}\StringTok{ }\NormalTok{(}\DecValTok{5} \OperatorTok{<}\StringTok{ }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

We can also negate a \texttt{TRUE} or \texttt{FALSE} value using the \texttt{!} symbol.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Negate an operation}
\OperatorTok{!}\NormalTok{(}\DecValTok{2} \OperatorTok{<}\StringTok{ }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Like relational operators from before, if we have more than one element the logical operations will be implemented element-by-element.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# AND event, compared element-by-element}
\NormalTok{(v }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{) }\OperatorTok{&}\StringTok{ }\NormalTok{(}\DecValTok{4} \OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# OR event, compared elmeent-by-elment}
\NormalTok{(v }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{) }\OperatorTok{|}\StringTok{ }\NormalTok{(}\DecValTok{4} \OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE
\end{verbatim}

We also have the symbols \texttt{\&\&} and \texttt{\textbar{}\textbar{}} which will ensure that only the first element in an object will be compared.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# AND event, only check the first element}
\NormalTok{(v }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\NormalTok{(}\DecValTok{4} \OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# OR event, only check the first element}
\NormalTok{(v }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{) }\OperatorTok{||}\StringTok{ }\NormalTok{(}\DecValTok{4} \OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\hypertarget{assignment-operators}{%
\subsection*{Assignment Operators}\label{assignment-operators}}
\addcontentsline{toc}{subsection}{Assignment Operators}

Assignment operators are used to assign values to a new object. There are many types of assignment operators, and they operate slightly differently. The two most common assignment operators are \texttt{=} and \texttt{\textless{}-}. With these operators the value to the left of the operator is the name of the new object and the value on the right is what the object is now equal to.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{5}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{5}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

The majority of the time we can use these two assignment operators above interchangeably, there are some exceptions though. There are several other assignment operators which are uncommon and should only be used by advanced users, \texttt{-\textgreater{}}, \texttt{\textless{}\textless{}-}, and \texttt{-\textgreater{}\textgreater{}}.

When we create new objects it is called \emph{binding}. Consider the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In this line of code the object \texttt{c(6,\ 2\ ,5)} is binded to the name \texttt{v}. That is, \texttt{v} acts as a reference (or a placeholder) for the object \texttt{c(6,\ 2,\ 5)}. Everywhere we see the object \texttt{v} we should mentally replace it with this vector.

\hypertarget{naming-conventions}{%
\section{Naming Conventions}\label{naming-conventions}}

R has rules when it comes to naming objects. An object may start with a letter or a \texttt{.}, and the remaining characters may consist of letters, digits, \texttt{.} or \texttt{\_}. There are also special types of objects that have already established names in R. For example, \texttt{NULL}, \texttt{TRUE}, \texttt{FALSE}, \texttt{if}, and \texttt{function} should not be used as a new object name. To see a list of these reserved object names type \texttt{?Reserved} in to your console.

\hypertarget{basic-calculations}{%
\section{Basic Calculations}\label{basic-calculations}}

There are many functions in R that work similarly to how we would see in excel, or in a calculator. Most of these calculator-like functions take in a vector as input. Vectors can have a single element, or multiple elements. We call these \textbf{vectorized} functions. There are in general two types of vectorized functions, \textbf{single element} functions, and \textbf{multiple element} functions. Single element functions take a vector as an input and applies the function to each element of this vector automatically. Examples include \texttt{exp()}, \texttt{log()} and \texttt{abs()}. Multiple element functions take a vector as an input and returns an object based on the entire vector. Examples include \texttt{mean()}, \texttt{prod()}, and \texttt{sd()}.

\begin{itemize}
\item
  \texttt{abs()}: Takes in a vector, and returns the absolute value of each element in the vector.
\item
  \texttt{sum()}: Takes in a vector, and returns the sum of all element in the vector.
\item
  \texttt{prod()}: Takes in a vector, and returns the product of all elements in the vector.
\item
  \texttt{exp()}: Takes in a vector, and returns \(e\) to the power of each element in that vector (i.e.~\(e^x\))
\item
  \texttt{log()}: Takes in a vector, and returns the NATURAL LOG of each element in the vector.
\item
  \texttt{log10()}: Takes in a vector, and returns the log (base ten) of each element in the vector.
\item
  \texttt{mean()}: Takes in a vector, and returns the mean of the values in the vector.
\item
  \texttt{median()}: Takes in a vector, and returns the median of the values in the vector.
\item
  \texttt{var()}: Takes in a vector, and returns the variance of the values in the vector.
\item
  \texttt{sqrt()}: If you give it a vector, it returns the square root of each element in the vector. If you give it a single number, it returns the square root of the number.
\item
  \texttt{sd()}: Takes in a vector, and returns the standard deviation of the values in the vector.
\item
  \texttt{range()}: Takes in a vector, and returns the minimum AND maximum of the values in the vector.
\end{itemize}

Notice also that these functions take a single \textbf{vector} as input. Consider the following two examples.

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{# Example 1: Three vectors of length 1 as input.  Only the}
\CommentTok{# first vector (i.e. 1) is used to calculate the mean}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{## [1] 1}

\CommentTok{# Example 2: One vector of length 3 as input.  All three}
\CommentTok{# numbers are used to calculate the mean.}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{## [1] 2}
\end{Highlighting}
\end{Shaded}

In the first function call three vectors, each of length 1, where supplied as input. However, this function only uses a single vector as input. Instead we need to make a vector, \texttt{c(1,2,3)}, so that all three numbers are considered when calculating the mean. Sometimes these functions will automatically combine all data supplied in the function call into a single vector for you to combat this problem. This is not always the case though! Be sure to arrange the data in the correct way when calling your functions.

\hypertarget{floating-point-error}{%
\section{Floating Point Error}\label{floating-point-error}}

Many programming languages calculate values using high level approximations of mathematical operations, instead of doing the mathematical operations directly. R might show you a number that is an approximation or rounded version of what it tried to calculate. However, R can keep track of more levels of decimal places than it is showing you. For example, consider the built in object \texttt{pi}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Built in object}
\NormalTok{pi}
\CommentTok{## [1] 3.141593}

\CommentTok{# My pi}
\NormalTok{my_pi <-}\StringTok{ }\FloatTok{3.141593}

\CommentTok{# Are these equal?}
\NormalTok{pi }\OperatorTok{==}\StringTok{ }\NormalTok{my_pi}
\CommentTok{## [1] FALSE}
\end{Highlighting}
\end{Shaded}

To us these numbers look identical, but that is not the case for the computer. The built-in object \texttt{pi} actually has a lot more decimal places that the computer is not showing us. This can happen with computations sometimes, even when formulas are mathematically equivalent. To combat this problem, there are several things we can do. One of which is to use the \texttt{round(x,\ d)} function. Here \texttt{x} is the numeber to round, and \texttt{d} is the amount of decimal points to round to.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi_new <-}\StringTok{ }\KeywordTok{round}\NormalTok{(pi, }\DecValTok{3}\NormalTok{)}

\NormalTok{my_pi_new <-}\StringTok{ }\KeywordTok{round}\NormalTok{(my_pi, }\DecValTok{3}\NormalTok{)}

\NormalTok{pi_new }\OperatorTok{==}\StringTok{ }\NormalTok{my_pi_new}
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{additional-resources}{%
\section*{Additional Resources}\label{additional-resources}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  \href{https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf}{Chapter 1 of ``CRAN Intro-to-R Manual''}
\item
  Videos:

  \begin{itemize}
  \tightlist
  \item
    \href{https://ucr.yuja.com/V/Video?v=2365045\&node=8476457\&a=437885577\&autoplay=1}{Getting Started 1 \textbar{} How to Download and Install RStudio}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368643\&node=8487538\&a=437248619\&autoplay=1}{Getting Started 2 \textbar{} Rstudio Introduction cont'd, More Tabs Explained}
  \end{itemize}
\end{itemize}

\hypertarget{atomic-vectors}{%
\chapter{Atomic Vectors}\label{atomic-vectors}}

At its core, R is an objected-oriented computational and programming environment. Everything in R is an object with different properties. In this chapter we will go over vectors, these are the core fundamental objects used in R. A vector in R is a 1-dimensional object. That is, it contains a sequence of elements in a particular order. For example, \texttt{v\ \textless{}-\ c(2,\ 6,\ 5)} is a vector with three elements. The first element is a 2, the second is a 6, and third is a 5. An object with just a single element, \texttt{w\ \textless{}-\ 3} is just a vector with only one value.

R can represent different types of data. The types include \texttt{double}, \texttt{integer}, \texttt{complex}, \texttt{logical}, \texttt{character}, and \texttt{raw}. These are the basic fundamental objects we can use in R and are referred to as the \texttt{atomic} values. For our class we will not need the \texttt{complex} type which stores complex numbers, and in practice \texttt{raw} is rarely used. We will concentrate on the remaining four types. Unlike other object-oriented languages we do not need to specify what type of object we are creating when we create it. Instead, R guesses the type of object you are creating. To create an atomic vector we use the concatenate function \texttt{c()}, where each element of the vector is separated by a comma. This function will always create an atomic vector.

\begin{itemize}
\item
  \texttt{double}: A vector of real numbers (numbers which may contain decimal values). We can create these vectors using decimal (12.34) or scientific form (.1234e2). When using numbers this is the default type used.
\item
  \texttt{integer}: A vector of integers (whole numbers). We can create these vectors using a integer followed by a letter \texttt{L}, i.e.~\texttt{5L}.
\item
  \texttt{logical}: A vector containing only \texttt{TRUE} or \texttt{FALSE} values. We can create the these vectors using \texttt{TRUE} and \texttt{FALSE} explicitly, or by doing \texttt{T} or \texttt{F}.
\item
  \texttt{character}: A vector containing strings. A string is a sequence of characters made using double quotes or single quotes, i.e.~``Hello'' and `Goodbye'.
\end{itemize}

An atomic vector only contains elements of the same type. If the function \texttt{c()} is given a mix of elements then it will convert these elements to be all of the same type according to a hierarchy of rules. The only exception to this is for \texttt{NA} values. The object \texttt{NA} is used to indicate missingness, or the lack of a value. The value \texttt{NA} can occur anywhere for all types of vectors. To check the object type we can use the \texttt{typeof()} function.

Vectors are among the most common types that are used. All of the different types of vectors we will learn about have special properties and a multitude of features that we can use. We discuss some of their key properties here, but will continue exploring and learning about their features, and introducing more object types throughout the course.

\hypertarget{examples}{%
\section{Examples}\label{examples}}

\hypertarget{double}{%
\subsection*{Double}\label{double}}
\addcontentsline{toc}{subsection}{Double}

Vectors containing double vectors are perhaps the most common. These objects are comparable to doubles in the programming language C. Both the variables \texttt{a} and \texttt{b} are \texttt{double} vectors. When you type a number R will default to creating a double vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\FloatTok{17.45}
\KeywordTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\DecValTok{5}
\KeywordTok{typeof}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{12.05}\NormalTok{, }\FloatTok{0.0123}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\hypertarget{integer}{%
\subsection*{Integer}\label{integer}}
\addcontentsline{toc}{subsection}{Integer}

We can also create integer vectors which are specifically made to store integer values. We can do this by following a whole number with the letter \texttt{L}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\NormalTok{5L}
\KeywordTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{typeof}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

Notice that when we define \texttt{b\textless{}-5} and \texttt{b\ \textless{}-\ 5L} and type \texttt{b} into our console it appears the same. That is, to the user the two definitions look the same. However, in R integers and doubles are stored in the computer differently and have different features. For the most part, the difference between integers and doubles is negligable; however, sometimes it can produce strange errors.

\hypertarget{logical}{%
\subsection*{Logical}\label{logical}}
\addcontentsline{toc}{subsection}{Logical}

Logical values are either \texttt{TRUE} or \texttt{FALSE} and are created by using logical or relational operators. In other words, they are created by using statements that compare variables. There are several ways to do logical statements as we saw in Section \ref{operators}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\NormalTok{(}\DecValTok{10} \OperatorTok{<}\StringTok{ }\DecValTok{11}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10} \OperatorTok{<}\StringTok{ }\DecValTok{11}\NormalTok{, }\DecValTok{4} \OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{, }\DecValTok{3} \OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

We can also assign a value as \texttt{TRUE} or \texttt{FALSE} manually by setting it equal to \texttt{TRUE} or \texttt{FALSE}, or by using \texttt{T} or \texttt{F}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\NormalTok{T}
\KeywordTok{typeof}\NormalTok{(c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Can mix up TRUE/FALSE and T/F}
\NormalTok{d <-}\StringTok{ }\KeywordTok{c}\NormalTok{(T, F, }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\hypertarget{character}{%
\subsection*{Character}\label{character}}
\addcontentsline{toc}{subsection}{Character}

\texttt{Character} values are text. They are often used as data values and labels.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Double quotes}
\NormalTok{first <-}\StringTok{ "George"}
\KeywordTok{typeof}\NormalTok{(first)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Single quotes}
\NormalTok{last <-}\StringTok{ "Washington"}
\KeywordTok{typeof}\NormalTok{(last)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{full <-}\StringTok{ }\KeywordTok{c}\NormalTok{(first, last)}
\KeywordTok{typeof}\NormalTok{(full)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\hypertarget{basic-features}{%
\section{Basic Features}\label{basic-features}}

R is a vectorized language, meaning most of the procedures, functions, and operations have been optimized to work with vectors. It is typically advantageous to utilize this feature.

\hypertarget{length}{%
\subsection{Length}\label{length}}

We have already learned that we can create vectors using the function \texttt{c()}, but this can also be used to make a vector larger. To see how many elements are in a vector we use the \texttt{length()} function

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(v1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(v1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v2 =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\FloatTok{0.41}\NormalTok{, }\FloatTok{-1.2}\NormalTok{, pi)}
\KeywordTok{typeof}\NormalTok{(v2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(v2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v =}\StringTok{ }\KeywordTok{c}\NormalTok{(v1, v2)}
\KeywordTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1.000000  5.000000  6.000000 -0.410000 -1.200000  3.141593
\end{verbatim}

\hypertarget{vectorized-operations-and-recylcing}{%
\subsection{Vectorized Operations and Recylcing}\label{vectorized-operations-and-recylcing}}

Vectors can be used in arithmetic computations. If the two vectors are of the same length, the computations are performed element-by-element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 }\OperatorTok{+}\StringTok{ }\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.590000 3.800000 9.141593
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 }\OperatorTok{*}\StringTok{ }\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.41000 -6.00000 18.84956
\end{verbatim}

Single numbers (scalars) will operate on all the vector elements in an expression.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{*}\StringTok{ }\NormalTok{v1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5 25 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1}\OperatorTok{/}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3333333 1.6666667 2.0000000
\end{verbatim}

If you have vectors of different sizes R will \emph{recycle} values in the smaller vector in order to complete the operation. Sometimes R will give you a \emph{warning} for this, but often it does not.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{)}

\NormalTok{a }\OperatorTok{+}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in a + b: longer object length is not a multiple of shorter object
## length
\end{verbatim}

\begin{verbatim}
## [1] 11 22 40
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{<}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in a < b: longer object length is not a multiple of shorter object
## length
\end{verbatim}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE
\end{verbatim}

\hypertarget{coercion}{%
\subsection{Coercion}\label{coercion}}

As mentioned above, all elements within a vector must be of the same type. If you attempt to create a vector where some elements are of a different type than the another then R will convert all the elements to be of one type. For example, observe what happens when we try to create a vector with logical and double values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, F, }\OtherTok{TRUE}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  0  1  5  6 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

In the above example the values for \texttt{TRUE} where converted into \texttt{1} and \texttt{FALSE} was converted into a \texttt{0}.

R did the above coercion automatically, but sometimes you will want to convert a vector type explicitly. To do this we use the \texttt{as.*()} functions, where \texttt{*} is replaced by ``double'', ``integer'', ``character'', or ``logical''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert to a character vector}
\NormalTok{char_d <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(d)}
\NormalTok{char_d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"  "0"  "1"  "5"  "6"  "10"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(char_d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert to an integer vector}
\NormalTok{e <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(e)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e <-}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(e)}
\KeywordTok{typeof}\NormalTok{(e)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

It is not always possible to convert vector types. Sometimes an element of a vector will fail to convert. If this happens a warning may be given, and the value is often replaced by \texttt{NA}.

\hypertarget{testing}{%
\subsection{Testing}\label{testing}}

We can also \emph{test} what type of object that we have using the \texttt{is.*()} function, where \texttt{*} is replaced by ``logical'', ``double'', ``integer'', or ``character''. These function will return \texttt{TRUE} is \texttt{*} matches the \texttt{typeof()} output, and will return \texttt{FALSE} if otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a double vector}
\NormalTok{a <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(a)  }\CommentTok{# Returns FALSE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.double}\NormalTok{(a)  }\CommentTok{# Returns TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\hypertarget{names}{%
\subsection{Names}\label{names}}

You can name elements of a vector as well. This will produce a \emph{named vector}. Instead of referring to an elements location in a vector by its order number, you can refer to the name. We can create names for a vector using three different methods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  When creating it.
\item
  By assigning a character vector to \texttt{names()}
\item
  Inline with \texttt{setNames()}
\end{enumerate}

To create a named vector using the first technique we use the \texttt{=} symbol where the name is on the left of the equal sign, and the element binded to that name is on the right. All of the atomic vectors can be defined so their elements are named.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Using Technique 1 for creating a named vector.}
\NormalTok{named1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{first =} \StringTok{"Abraham"}\NormalTok{, }\DataTypeTok{last =} \StringTok{"Lincoln"}\NormalTok{)}
\NormalTok{named1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     first      last 
## "Abraham" "Lincoln"
\end{verbatim}

To create a named vector using the second technique we use the \texttt{names()} function. This is the most common technique.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Using Technique 2 for creating a named vector}
\NormalTok{named2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{names}\NormalTok{(named2) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"first"}\NormalTok{, }\StringTok{"second"}\NormalTok{, }\StringTok{"third"}\NormalTok{)}
\NormalTok{named2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  first second  third 
##      1      2      3
\end{verbatim}

To create a named vector using the third technique we use the \texttt{setNames()} function. This is the least common technique and is hardly used.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Using Technique 3 for creating a named vector}
\NormalTok{named3 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(T, F, T)}
\NormalTok{named3 <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(named3, }\KeywordTok{c}\NormalTok{(}\StringTok{"e1"}\NormalTok{, }\StringTok{"e2"}\NormalTok{, }\StringTok{"e3"}\NormalTok{))}
\NormalTok{named3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    e1    e2    e3 
##  TRUE FALSE  TRUE
\end{verbatim}

To see the list of names for a vector at any point use the \texttt{names()} function. When this function is on the right side of an assignment operator this will produce the names of each element of the vector.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# To see the names of a vector and not the elements}
\KeywordTok{names}\NormalTok{(named3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "e1" "e2" "e3"
\end{verbatim}

If you want to remove the names of a vector you can use two techniques. The first technique is to redefined the vector you with to remove the names of with the \texttt{unname()} function. The second technique uses the \texttt{names()} function and sets the names to be equal to \texttt{NULL}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Remove names using unname()}
\NormalTok{named2 <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(named2)}
\NormalTok{named2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Remove names using names() and NULL}
\KeywordTok{names}\NormalTok{(named3) <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{named3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE  TRUE
\end{verbatim}

\hypertarget{typeof-and-class}{%
\subsection{typeof() and class()}\label{typeof-and-class}}

The \texttt{typeof()} function returns the storage mode of an object, and the types of values this function will return is limited. The six atomic types of vectors each are based on the six fundamental ways R stores data. Thus when we make a standard vector, we can use the \texttt{typeof()} function to see which type of vector we have. There is also a function called \texttt{class()} which is more common to use, and what we will focus on for the rest of the course. The \texttt{class()} function returns very similar output as \texttt{typeof()}, but it can also return more specific types or forms of objects. For example, perhaps you have a vector with special properties or set up. Then you can assign this specific type of vector with a certain class that reflects these properties, and R will know to differentiate how it handles this object based on its class, instead of its storage mode (returned by \texttt{typeof()}). The major difference between the output of \texttt{typeof()} and \texttt{class()} for atomic vectors is that when we have an integer or double vector the class function returns ``numeric'' for both.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v_int <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{class}\NormalTok{(v_int)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v_dbl <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{class}\NormalTok{(v_dbl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\hypertarget{index}{%
\subsection{Accessing Elements of a Vector}\label{index}}

Individual elements of a vector can be obtained using an index in square brackets. An \emph{index} is the location of an element in a vector. For example, the vector \texttt{v\_dbl\textless{}-\ c(10,\ 11,\ 12)} has three elements. The first elements index is 1, the second elements index is 2, and so on. A negative index removes that element from the vector. The \texttt{v\_dbl{[}-1{]}} is the vector \texttt{v\_dbl} with the first element removed. The concatenate function can be used to obtain two or more elements of a vector in any desired order. Here \texttt{v\_dbl{[}c(3,2){]}} returns the third and second elements of the vector \texttt{v\_dbl}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v_dbl <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{)}

\CommentTok{# Only get the third element}
\NormalTok{v_dbl[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Get all elements except the first one}
\NormalTok{v_dbl[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Get the third and second element}
\NormalTok{v_dbl[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12 11
\end{verbatim}

\hypertarget{summary}{%
\section*{Summary}\label{summary}}
\addcontentsline{toc}{section}{Summary}

\begin{itemize}
\item
  There are 6 types atomic vectors, but four we will primarily focus on: character, logical, integer, and double.
\item
  The \texttt{c()} function is used to create atomic vectors, and it combines vectors together.
\item
  All elements of a vector are of the same type.
\item
  \texttt{typeof()} and \texttt{class()} functions return what type of vector you have.
\item
  The \texttt{length()} function tells us how many elements are in a vector.
\item
  The \texttt{names()} and \texttt{setNames()} function can be used to create a named vector.
\item
  \texttt{as.*()} can be used to convert the type of vector.
\item
  \texttt{is.*()} can be used to test what type of vector you have.
\item
  We can access an element of a atomic vector by using \texttt{v{[}num{]}}, where \texttt{v} is the vector, and \texttt{num} is the index (or location) of the element we are trying to access.
\end{itemize}

Summary of the vectors that we will be learning about.

\begin{center}\includegraphics[width=8in]{images/Vector_chart} \end{center}

\hypertarget{additional-resources-1}{%
\section*{Additional Resources}\label{additional-resources-1}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  Chapters 2, 3, 4.1, 4.3, 5.1-5.3, 6 of \href{https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf}{CRAN Intro-to-R Manual}
\item
  Videos:

  \begin{itemize}
  \tightlist
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368642\&node=8487537\&a=1529691043\&autoplay=1}{Variables 1 \textbar{} Types and Assignments}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368641\&node=8487536\&a=957339369\&autoplay=1}{Variables 2 \textbar{} Nameing Conventions and Best Practices}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368859\&node=8488053\&a=283774152\&autoplay=1}{Vectors 1 \textbar{} Introduction}
  \end{itemize}
\item
  Chapters 4.6-4.8 of \href{https://bookdown.org/rdpeng/rprogdatascience/}{Chapter 13 of ``R for Programming in Data Science''}
\item
  Chapter 4 of \href{https://adv-r.hadley.nz/index.html}{Adanvced R}
\end{itemize}

\hypertarget{factors-and-lists}{%
\chapter{Factors and Lists}\label{factors-and-lists}}

Factor objects and lists are vectors with special properties. Factors and lists are vectors because they a 1-dimensional sequence of elements. Factors are primarily used for categorical data, and are technically a special form of an integer type vector. However, we will simply refer to a factor vector a as a factor object. Lists are vectors where type of each element can differ. In this chapter we introduce some of the unique properties of factors and lists.

\hypertarget{factors}{%
\section{Factors}\label{factors}}

In real-world problems, you often encounter data that can be classified in categories. For example, suppose a survey was conducted of a group of seven individuals, who were asked to identify their hair color.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hair <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Red"}\NormalTok{, }\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Brown"}\NormalTok{,}
    \StringTok{"Black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here, the hair color is an example of categorical data. For the hair color variable we will typically want to store it as a factor, as opposed to a character vector. The different values that the factor can take are called levels. In R, you can create a factor with the \texttt{factor()}, or the \texttt{as.factor()} functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(hair)}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Blonde Black  Black  Red    Blonde Brown  Black 
## Levels: Black Blonde Brown Red
\end{verbatim}

\hypertarget{levels}{%
\subsection{Levels}\label{levels}}

Levels are one of the special properties of a factor object. Notice that when you print the factor, R displays the distinct levels below the factor. R keeps track of all the possible values in a vector, and each value is called a level of the associated factor. The \texttt{levels()} function shows all the levels from a factor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{levels}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Black"  "Blonde" "Brown"  "Red"
\end{verbatim}

If your vector contains only a subset of all the possible levels, then R will have an incomplete picture of the possible levels. Consider the following example of a vector consisting of directions. Notice that ``South'' is noticeably missing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{directions <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"North"}\NormalTok{, }\StringTok{"West"}\NormalTok{, }\StringTok{"North"}\NormalTok{, }\StringTok{"East"}\NormalTok{, }\StringTok{"North"}\NormalTok{, }\StringTok{"West"}\NormalTok{,}
    \StringTok{"East"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(directions)}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] North West  North East  North West  East 
## Levels: East North West
\end{verbatim}

Notice that the levels of your new factor do not contain the value ``South''. R thinks that North, West, and East are the only possible levels. However, in practice, it makes sense to have all the possible directions as levels of your factor. To add all the possible levels explicitly, you specify the \texttt{levels} argument of the function \texttt{factor()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Make sure all possible categories are listed using the}
\CommentTok{# levels argument}
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(directions, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"North"}\NormalTok{, }\StringTok{"East"}\NormalTok{, }\StringTok{"South"}\NormalTok{,}
    \StringTok{"West"}\NormalTok{))}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] North West  North East  North West  East 
## Levels: North East South West
\end{verbatim}

R lets you assign abbreviated names for the levels. You can do this by specifying the \texttt{labels} argument of \texttt{factor()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(directions, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"North"}\NormalTok{, }\StringTok{"East"}\NormalTok{, }\StringTok{"South"}\NormalTok{,}
    \StringTok{"West"}\NormalTok{), }\DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"N"}\NormalTok{, }\StringTok{"E"}\NormalTok{, }\StringTok{"S"}\NormalTok{, }\StringTok{"W"}\NormalTok{))}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] N W N E N W E
## Levels: N E S W
\end{verbatim}

\hypertarget{ordered-factor}{%
\subsection{Ordered Factor}\label{ordered-factor}}

Sometimes data has some kind of natural order between elements. For example, sports analysts use a three-point scale to determine how well a sports team is competing:

\textbf{loss \textless{} tie \textless{} win}.

In market research, it's very common to use a five point scale to measure perceptions:

\textbf{strongly disagree \textless{} disagree \textless{} neutral \textless{} agree \textless{} strongly agree}.

Such kind of data that is possible to place in order or scale is known as \textbf{ordinal data}. We can store ordinal data as an ordered factor. To create an ordered factor, use the \texttt{factor()} function with the argument \texttt{ordered=TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"tie"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"tie"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{, }\StringTok{"win"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(record, }\DataTypeTok{ordered =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] win  tie  loss tie  loss win  win 
## Levels: loss < tie < win
\end{verbatim}

You can manually change which levels are lower and higher based on the order that the levels are listed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"tie"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"tie"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{, }\StringTok{"win"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(record, }\DataTypeTok{ordered =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"tie"}\NormalTok{,}
    \StringTok{"loss"}\NormalTok{))}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] win  tie  loss tie  loss win  win 
## Levels: win < tie < loss
\end{verbatim}

If you have no observations in one of the levels, you can drop it using the \texttt{droplevels()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{)}
\NormalTok{f =}\StringTok{ }\KeywordTok{factor}\NormalTok{(record, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"loss"}\NormalTok{, }\StringTok{"tie"}\NormalTok{, }\StringTok{"win"}\NormalTok{))}

\KeywordTok{droplevels}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] win  loss loss win  loss win 
## Levels: loss win
\end{verbatim}

\hypertarget{factors---basic-features}{%
\section{Factors - Basic Features}\label{factors---basic-features}}

\hypertarget{length-1}{%
\subsection{Length}\label{length-1}}

Factor objects have a lot of the same features as atomic vectors. In general, most of the features and functions we had for atomic vectors work with factors. For example, we still use the \texttt{length()} function to see how many elements are in a factor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\hypertarget{coercion-1}{%
\subsection{Coercion}\label{coercion-1}}

Coercion also works similarly. We can use \texttt{as.factor()} to create a factor object from a pre-existing vector. As we have seen in the previous examples, the \texttt{factor()} function also works.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{as.factor}\NormalTok{(record)}
\NormalTok{f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] win  loss loss win  loss win 
## Levels: loss win
\end{verbatim}

To convert a factor object to a non-factor object we still use the \texttt{as.*()} function. In general, it is usually easiest to convert character vectors to factor vectors, and vice versa. When we convert a factor to an integer or double vector the different levels of the factor are converted to integers in order for each level. That is, the first level listed is converted to a 1, the second level listed is converted to a 2, and so on.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert to a character vector}
\KeywordTok{as.character}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "win"  "loss" "loss" "win"  "loss" "win"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert to an integer vector}
\KeywordTok{as.integer}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 1 1 2 1 2
\end{verbatim}

\hypertarget{testingclass}{%
\subsection{Testing/Class}\label{testingclass}}

We can also test if we have factor or an ordered factor using \texttt{is.*()} as we did before.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{, }\StringTok{"loss"}\NormalTok{, }\StringTok{"win"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(record, }\DataTypeTok{ordered =}\NormalTok{ T)}


\CommentTok{# Test if the character vector is a factor}
\KeywordTok{is.factor}\NormalTok{(record)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Test if we have a factor (includes both ordered and not}
\CommentTok{# ordered factors)}
\KeywordTok{is.factor}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Test if we have an ordered factor (only includes ordered}
\CommentTok{# factors)}
\KeywordTok{is.ordered}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

With all types of objects we can use the \texttt{class()} function. As mentioned in the previous section, this function returns the name of the type of object that you have, unlike \texttt{typeof()} which returns the storage mode. The output of \texttt{class()} returns name of a object with particular properties. For instance, a factor object. A factor object is stored like an integer vector but it has ``levels'' which can be utilized in special ways.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns storage mode (not recommended)}
\KeywordTok{typeof}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns class, which is the name of a collection of}
\CommentTok{# objects with similar properties (Recommended)}
\KeywordTok{class}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ordered" "factor"
\end{verbatim}

\hypertarget{names-1}{%
\subsection{Names}\label{names-1}}

Like standard vectors, we can name the elements in a factor using the same three techniques discussed in \ref{names}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Using Technique 1 for creating a named vector.}
\NormalTok{named1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{sally =} \StringTok{"win"}\NormalTok{, }\DataTypeTok{tom =} \StringTok{"win"}\NormalTok{, }\DataTypeTok{ed =} \StringTok{"lost"}\NormalTok{, }\DataTypeTok{jane =} \StringTok{"tie"}\NormalTok{)}
\NormalTok{named1 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(named1)}
\NormalTok{named1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## sally   tom    ed  jane 
##   win   win  lost   tie 
## Levels: lost tie win
\end{verbatim}

\hypertarget{accessing-elements}{%
\subsection{Accessing Elements}\label{accessing-elements}}

We can also access elements of a factor object using the same standard techniques described for accessing elements in a vector \ref{index}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtain the first element}
\NormalTok{named1[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## sally 
##   win 
## Levels: lost tie win
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtain the forth and second elements}
\NormalTok{named1[}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## jane  tom 
##  tie  win 
## Levels: lost tie win
\end{verbatim}

\hypertarget{frequency-tables}{%
\subsection{Frequency Tables}\label{frequency-tables}}

The \texttt{summary()} function will give you a quick overview of the contents of a factor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hair <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Red"}\NormalTok{, }\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Brown"}\NormalTok{,}
    \StringTok{"Black"}\NormalTok{)}
\NormalTok{hair <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(hair)}
\KeywordTok{summary}\NormalTok{(hair)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  Black Blonde  Brown    Red 
##      3      2      1      1
\end{verbatim}

The function \texttt{table()} tabulates observations.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(hair)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## hair
##  Black Blonde  Brown    Red 
##      3      2      1      1
\end{verbatim}

We can also use the \texttt{table()} and \texttt{summary()} functions on atomic vectors, and they will operate in a similar way. However, these functions are particularly utilized for factor objects.

The \texttt{table()} function can also tabulate two-way frequency tables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hair <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Black"}\NormalTok{, }\StringTok{"Red"}\NormalTok{, }\StringTok{"Blonde"}\NormalTok{, }\StringTok{"Brown"}\NormalTok{,}
    \StringTok{"Black"}\NormalTok{)}
\NormalTok{own_pets <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}

\NormalTok{hair <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(hair)}
\NormalTok{own_pets <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(own_pets)}


\CommentTok{# Two way table}
\KeywordTok{table}\NormalTok{(hair, own_pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         own_pets
## hair     FALSE TRUE
##   Black      2    1
##   Blonde     1    1
##   Brown      1    0
##   Red        0    1
\end{verbatim}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

A \emph{list} is an array of objects. Unlike other types of vectors, the elements in a list can belong to different classes. Lists are useful for packaging together a set of related objects. We can create a list of objects in our environment by using the \texttt{list()} function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# A list of mixed datatypes}
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(1L, }\KeywordTok{c}\NormalTok{(}\StringTok{"abc"}\NormalTok{, }\StringTok{"ABC"}\NormalTok{), }\FloatTok{1.23}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{lst}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] "abc" "ABC"
## 
## [[3]]
## [1] 1.23
## 
## [[4]]
## [1] TRUE
\end{verbatim}

Looking at the output above we can see that this output is structured differently than a standard vector. The location of each element of a list is denoted by {[}{[}{]}{]} instead of {[}{]}.

The best way to understand the contents of a list is to use the structure function \texttt{str()}. It provides a compact display of the internal structure of a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"abc"}\NormalTok{, }\StringTok{"ABC"}\NormalTok{), }\FloatTok{1.23}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{str}\NormalTok{(lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 4
##  $ : num 1
##  $ : chr [1:2] "abc" "ABC"
##  $ : num 1.23
##  $ : logi TRUE
\end{verbatim}

Above we see that we have a list with 4 elements. The first element is of class ``numeric'' and contains a single number, 1. The second element is of ``character'' and contains two elements, which is indicated by {[}1:2{]}. The third and fourth elements are of class ``numeric'' and ``logical'', and each contain a single element.

To see the class of each indivdiual element of a list we can use the following command.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(lst, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"   "character" "numeric"   "logical"
\end{verbatim}

\hypertarget{nested-lists}{%
\subsection{Nested Lists}\label{nested-lists}}

A list can contain sublists, which in turn can contain sublists themselves, and so on. This is known as \emph{nested list} or \emph{recursive vectors}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"abc"}\NormalTok{, }\StringTok{"ABC"}\NormalTok{), }\KeywordTok{list}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{str}\NormalTok{(lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 5
##  $ : num 1
##  $ : num 3
##  $ : chr [1:2] "abc" "ABC"
##  $ :List of 3
##   ..$ : chr "a"
##   ..$ : chr "b"
##   ..$ : chr "c"
##  $ : logi TRUE
\end{verbatim}

\hypertarget{list---basic-features}{%
\section{List - Basic Features}\label{list---basic-features}}

\hypertarget{length-2}{%
\subsection{Length}\label{length-2}}

Despite looking different and being stored differently than atomic vectors and factors, lists have many of the same properties and features. For example, we still can use the \texttt{length()} function to determine how many elements are in a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"abc"}\NormalTok{, }\StringTok{"ABC"}\NormalTok{), }\KeywordTok{list}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{length}\NormalTok{(lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

In the example of both there are 5 items in a list. The first two elements are double vectors of length 1, the third element is a character vector of length two, the fourth element is a list of length three, and the fifth element is a logical vector of length 1.
Add elements to a list using \texttt{c()} as we did before with atomic vectors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst_char <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}
\NormalTok{lst_num <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{99}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{lst <-}\StringTok{ }\KeywordTok{c}\NormalTok{(lst_num, lst_char)}
\KeywordTok{str}\NormalTok{(lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 6
##  $ : num 100
##  $ : num 99
##  $ : num 0
##  $ : chr "a"
##  $ : chr "b"
##  $ : chr "c"
\end{verbatim}

\hypertarget{coercion-2}{%
\subsection{Coercion}\label{coercion-2}}

We can convert atomic vectors and factors into lists by simply using the \texttt{as.list()} function. The \texttt{as.list()} function lets each element in a vector correspond to each element in the list. So the first element of the vector becomes the first element of the list, the second element of the vector becomes the second element of the list, and so on. We could also use the \texttt{list()} function but this will convert a vector into a list in a different way.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num_vec <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{num_lst <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(num_vec)}
\KeywordTok{str}\NormalTok{(num_lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ : num 1
##  $ : num 2
##  $ : num 3
\end{verbatim}

We can convert lists to one of the other types of vectors using the \texttt{as.*()} function with the desired vector type as we did earlier. However, if we do not have a desired type in mind we can also use the \texttt{unlist()} function. The \texttt{unlist()} function takes all atomic objects in a list and creates an atomic vector. In this case R will ``guess'' which type of atomic vector you would like.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unlist}\NormalTok{(num_lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\hypertarget{testingclass-1}{%
\subsection{Testing/Class}\label{testingclass-1}}

We can determine if an object is a list or not by using \texttt{is.list()} or the \texttt{class()} functions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.list}\NormalTok{(num_lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(num_lst)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\hypertarget{names-2}{%
\subsection{Names}\label{names-2}}

Lists can also be named, and often are. It is very common to created named lists because lists can have a mix of different types objects. We can create a named list using all the same techniques that we used for creating named vectors (\ref{names}) . Notice, we do not have to create a name for every element in a list. Below we see the first two elements are named, and the last is not.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{first =} \StringTok{"Abraham"}\NormalTok{, }\DataTypeTok{last =} \StringTok{"Lincoln"}\NormalTok{, }\DecValTok{1860}\NormalTok{)}
\NormalTok{lst}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $first
## [1] "Abraham"
## 
## $last
## [1] "Lincoln"
## 
## [[3]]
## [1] 1860
\end{verbatim}

\hypertarget{accessing-elements-1}{%
\subsection{Accessing Elements}\label{accessing-elements-1}}

Accessing elements in a list is a little different than accessing elements in a vector. As you may have already noticed, when a list is outputted into our console the elements in the list are denoted by their index number inside of double brackets, i.e.~{[}{[}2{]}{]}. To access this individual element in a list we use double brackets. This isolates that individual element, and the class of this element is no longer a list but the class of the original element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Abraham"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(lst[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

We can still use single brackets to access elements in a list, but this method of indexing simply subsets the list. That is, it still returns us a list, just a smaller one based on the indices called.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $first
## [1] "Abraham"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(lst[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"abc"}\NormalTok{, }\StringTok{"ABC"}\NormalTok{), }\KeywordTok{list}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{lst[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "abc" "ABC"
## 
## [[2]]
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(lst[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\hypertarget{summary-1}{%
\section*{Summary}\label{summary-1}}
\addcontentsline{toc}{section}{Summary}

\begin{itemize}
\item
  Factors are special types of vectors which are primarily used for categorical data.
\item
  Factors can be ordered or unordered.
\item
  We create factor objects using the \texttt{factor()} function.
\item
  Lists are vectors which can have a mix of classes/types of objects.
\item
  We create a factor or list using the functions \texttt{factor()} or \texttt{list()}
\item
  We can use the same basic functions with factors and lists as we do with atomic vectors: \texttt{length()}, \texttt{as.*()}, \texttt{is.*()}, \texttt{class()}
\item
  We have the same basic properties with factors and lists as we do with atomic vectors:

  \begin{itemize}
  \item
    \texttt{length()} determine how long an object is
  \item
    \texttt{c()} combine two objects of the same class together
  \item
    same naming techniques
  \item
    same indexing strategies
  \end{itemize}
\item
  We can also access individual elements of a list using {[}{[}{]}{]}, which isolates an element and takes it out of the list structure.
\end{itemize}

\hypertarget{additional-resources-2}{%
\section*{Additional Resources}\label{additional-resources-2}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  Chapters 4.10, 4.11 of \href{https://bookdown.org/rdpeng/rprogdatascience/}{Chapter 13 of ``R for Programming in Data Science''}
\item
  Chapters
\end{itemize}

\textbf{Excercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Build a factor object with 3 levels, and 5 elements.
\item
  Convert the \texttt{directions} vector above to a factor with the levels \texttt{North,\ west,\ East,\ South}. What happened to the values for \texttt{West}?
\item
  Can we convert a logical vector into a factor vector? What about the other way around?
\item
  Create a list with four elements:

  \begin{itemize}
  \item
    a character vector of length 2 that contains your first and last name
  \item
    a numeric vector of length 1 that contains your age
  \item
    a factor object from somewhere in this chapter
  \item
    an object of your choice
  \end{itemize}
\item
  Adjust/redefine your list in (4) so that way it is a named list.
\end{enumerate}

\hypertarget{matrices-data-frames-and-more}{%
\chapter{Matrices, Data Frames, and More}\label{matrices-data-frames-and-more}}

\hypertarget{matrices}{%
\section{Matrices}\label{matrices}}

A matrix is a two dimensional array of data of \textbf{the same type}. The matrix function, \texttt{matrix()}, can be used to create a new matrix.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    0    3
## [2,]    9    5    8
## [3,]    2    7    4
\end{verbatim}

R labels the rows and columns for us in the output. The matrix is filled column-by-column using the elements of the vector created by the concatenate function. The matrix \texttt{m} above is a matrix composed of doubles (the atomic object). This is the default type of matrix R creates, and it is by far the most common matrix used. However, we can also create integer matrices, logical matrices, and character matrices.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example of a matrix with logical values}
\NormalTok{m_logical <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, T, T, F, F, F, T, T), }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{m_logical}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1]  [,2]
## [1,]  TRUE FALSE
## [2,]  TRUE FALSE
## [3,]  TRUE  TRUE
## [4,] FALSE  TRUE
\end{verbatim}

\hypertarget{vectorized-operations}{%
\subsection{Vectorized Operations}\label{vectorized-operations}}

As with vectors, matrices can be used in arithmetic operations with scalars and other matrices of the same size. We still have all the same basic vectorized operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2 <-}\StringTok{ }\NormalTok{m}\OperatorTok{/}\DecValTok{2}
\NormalTok{m2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]  0.5  0.0  1.5
## [2,]  4.5  2.5  4.0
## [3,]  1.0  3.5  2.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OperatorTok{*}\StringTok{ }\NormalTok{m2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]  0.5  0.0  4.5
## [2,] 40.5 12.5 32.0
## [3,]  2.0 24.5  8.0
\end{verbatim}

\hypertarget{data-frames}{%
\section{Data Frames}\label{data-frames}}

Like a matrix, a data frame is a rectangular array of values where each column is a vector. However, unlike a matrix, the columns can be different data types. We can create a set of vectors of the same length and use the \texttt{data.frame()} function to make a data frame object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{)}
\NormalTok{gender <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Female"}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{)}
\NormalTok{married <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{simpsons <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(age, gender, married)}
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   age gender married
## 1   1 Female   FALSE
## 2   8 Female   FALSE
## 3  10   Male   FALSE
## 4  30 Female    TRUE
## 5  31   Male    TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.frame"
\end{verbatim}

To see all the class of each column in a data frame we can use the following command.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(simpsons, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         age      gender     married 
##   "numeric" "character"   "logical"
\end{verbatim}

\hypertarget{column-names}{%
\subsection{Column Names}\label{column-names}}

Data frames always have column names. In the example above we used vectors to create a data frame. When we use this technique then the name of the vector is automatically selected as the column name. If we have inputted a vector like \texttt{c(1,\ 2,\ 3,\ 4,\ 5)} as an argument in the \texttt{data.frame()} function instead of an object name, then R would have guessed what to name the column. Matrices do not have this property. Matrices do not usually have column or row names (but they can, as we will see below). In contrast, data frames always have column names, and often have row names too. In the following section we discuss how to change the row and column names of both matrices and data frames explicitly.

\hypertarget{basic-features-of-matricesdata-frames}{%
\section{Basic Features of Matrices/Data-Frames}\label{basic-features-of-matricesdata-frames}}

\hypertarget{dimensions}{%
\subsection{Dimensions}\label{dimensions}}

To access and determine the size or dimensions of a matrix and data frame there are three important functions. We no longer would want to use the \texttt{length()} function because that is for 1-dimsional objects. Since matrices and data frames are 2-dimensional objects we now must consider both dimensions. The three functions we can use to do this are \texttt{dim()}, \texttt{nrow()}, and \texttt{ncol()}. The \texttt{dim()} function returns the number of rows and the number of columns. The \texttt{nrow()} just returns the number of rows, and \texttt{ncol()} just returns the number of columns.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dim}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nrow}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ncol}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\hypertarget{accesing-elements}{%
\subsection{Accesing Elements}\label{accesing-elements}}

Indices can be used to obtain the elements of a matrix and data frame, but now we must consider both the row and column. We can access an individual point in a matrix or data frame using \texttt{{[}row,\ colum{]}}, where \texttt{row} is the row index and \texttt{column} is the column index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{m[}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

We can access multiple elements using the \texttt{c()} function. Note we must use the \texttt{c()} function to separate the rows and columns we are trying isolate because the common inside the single brackets separates the dimensions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate multiple individual points.}
\NormalTok{m[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
\end{verbatim}

We can also isolate entire rows or columns by leaving one of the dimensions blank.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate the second row}
\NormalTok{m[}\DecValTok{2}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9 5 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate the third column}
\NormalTok{m[, }\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 8 4
\end{verbatim}

We can think of these individual rows or columns as an individual vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\NormalTok{simpsons[, }\DecValTok{2}\NormalTok{]}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Female" "Female" "Male"   "Female" "Male"
\end{verbatim}

\hypertarget{coercion-3}{%
\subsection{Coercion}\label{coercion-3}}

We often do not need to convert matrices and data frames, but if we do we can use the \texttt{as.matrix()} or \texttt{as.data.frame()} on a pre-existing object to convert it into a matrix or data frame. The most common type of coercion that we have for 2-dimensional objects is changing the class of a column in a data frame. To do this we can redefine this class explicitly using indexing.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Changing the class of a single column}
\NormalTok{simpsons[, }\DecValTok{1}\NormalTok{] <-}\StringTok{ }\KeywordTok{as.factor}\NormalTok{(simpsons[, }\DecValTok{1}\NormalTok{])}

\KeywordTok{sapply}\NormalTok{(simpsons, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         age      gender     married 
##    "factor" "character"   "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   age gender married
## 1   1 Female   FALSE
## 2   8 Female   FALSE
## 3  10   Male   FALSE
## 4  30 Female    TRUE
## 5  31   Male    TRUE
\end{verbatim}

\hypertarget{testingclass-2}{%
\subsection{Testing/Class}\label{testingclass-2}}

We can test or determine what type of object we have using the \texttt{class()} function. Again, this function will always return something for a given object. If we have a data frame or matrix it will return ``data.frame'' or ``matrix'', respectively. We can also use the \texttt{is.matrix()} or \texttt{is.data.frame()} functions which will return \texttt{TRUE/FALSE} values.

\hypertarget{names-3}{%
\subsection{Names}\label{names-3}}

With both matrices and data frames we can name the rows and columns. Data frames will always have column names, but matrices do not have to have them. It is very commmon to name the rows and columns for a data frame, but not as common for matrices. Matrices are most often used for linear algebra calculations. To see the row or column names of a 2-dimensional object we can use the \texttt{rownames()} and \texttt{colnames()} functions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rownames}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "2" "3" "4" "5"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(simpsons)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "age"     "gender"  "married"
\end{verbatim}

To change these names we use the same functions, and just manually reassign the values for them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rownames}\NormalTok{(simpsons) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Maggie"}\NormalTok{, }\StringTok{"Lisa"}\NormalTok{, }\StringTok{"Bart"}\NormalTok{, }\StringTok{"Marge"}\NormalTok{, }\StringTok{"Homer"}\NormalTok{)}
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        age gender married
## Maggie   1 Female   FALSE
## Lisa     8 Female   FALSE
## Bart    10   Male   FALSE
## Marge   30 Female    TRUE
## Homer   31   Male    TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(simpsons) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Age"}\NormalTok{, }\StringTok{"Gender"}\NormalTok{, }\StringTok{"Married"}\NormalTok{)}
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        Age Gender Married
## Maggie   1 Female   FALSE
## Lisa     8 Female   FALSE
## Bart    10   Male   FALSE
## Marge   30 Female    TRUE
## Homer   31   Male    TRUE
\end{verbatim}

\hypertarget{other-object-types-and-the-global-environment}{%
\section{Other Object Types and the Global Environment}\label{other-object-types-and-the-global-environment}}

There are more objects then what we have discussed above. For example, many of the advanced functions create specific objects generated by that specific function. There are hundreds, and possibly thousands, of such objects. These objects generally are special cases of lists, factors, and other various types of objects that we have defined in this section. The objects we have described here are the building blocks of most values we will be working with. Functions like \texttt{class()} and \texttt{length()} are also considered as objects, but are of a different type. We discuss functions in more detail in section \ref{functions}.

There are also built-in, or special objects in R. For example, the object \texttt{pi} is an object already defined. These built-in values and functions can be written over, but that is not advised.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.141593
\end{verbatim}

Every time we create an object we see that the Global Environment tab in the top right pane updates. The object we have created is now listed in the Global Environment. This is a collection of all \emph{user created} objects in R, that R knows about, and that R can easily call. Built-in objects, such as \texttt{pi}, will not be listed here.

\hypertarget{summary-2}{%
\section*{Summary}\label{summary-2}}
\addcontentsline{toc}{section}{Summary}

\begin{itemize}
\item
  The basic and most common 2-dimensional objects are matrices and data frames.
\item
  Matrices must contain all data of the same type.
\item
  Data frames can have different classes between columns, and always have column names.
\item
  We can create a matrix or data frame using the \texttt{matrix()} and \texttt{data.frame()} functions.
\item
  Many vectorized operations still work for 2-dimensional objects.
\item
  We can look at and name both rows and columns using \texttt{rownames()} and \texttt{colnames()}.
\item
  To see the dimensions of a 2-dimensional object we use \texttt{dim()}, \texttt{nrow()} and \texttt{ncol()}.
\item
  We can check if we have a matrix or data frame by using \texttt{class()} or \texttt{is.*()}.
\item
  To access elements of a 2-dimsional object we use \texttt{{[}row,\ column{]}}.
\end{itemize}

\hypertarget{indexing}{%
\chapter{Indexing}\label{indexing}}

When we wish to extract elements of an object like a vector, list, data frame, or matrix, we use a process called \emph{indexing}. The process of indexing, is also sometimes called \emph{subsetting}. In R the \emph{index} of an object is the numeric location of that object. For example, consider the vector \texttt{vec\ \textless{}-\ c(100,\ 20,\ 3)}. The index of the first element is 1, the index of the second element is 2, and the so on. We have already seen a few examples of indexing for vectors and factors, lists, and 2D objects. In this section we more formally describe a plethora of indexing techniques. Indexing can be hard to master in R because of the many options, and the different types of objects. In this section we will describe the basic indexing techniques for atomic vector and factors, lists, matrices, and data frames. The indexing between the methods are all related, so it useful to talk about them all together. At the end of this section we give examples of a few features and applications we can do with indexing.

\hypertarget{VectorIndex}{%
\section{Atomic Vectors and Factors}\label{VectorIndex}}

We have already seen a little big of indexing with vectors (atomic, factors, and lists). Now we will discuss indexing in more detail for 1D Objects. We will focus specifically on atomic vectors. The techniques here can be used with other types and classes of vectors though. For indexing with vectors we only have one indexing operator, \texttt{{[}{]}}. We also have four general strategies that we will focus on. Suppose we wish to preform indexing on a vector \texttt{vec}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Generate a random vector with the following code}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{vec <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)  }\CommentTok{# numeric vector with 10 values}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  9 74 76 55 72 54 39 83 88 15
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Four basic strategies:

  \begin{itemize}
  \tightlist
  \item
    \textbf{positive integer}: When using the positive integer strategy we use a vector \texttt{index} which only contains positive integers of the indexes. This vector can be of any positive finite length. That means it can be of length 1, length 10, or even length 10000. We use this operator by calling \texttt{vec{[}index{]}}, which will return the elements of \texttt{vec} by their indices as ordered from \texttt{index}.
  \item
    \textbf{negative integer}: The negative integer strategy works similarly. This time we consider a vector \texttt{index} which only contains negative integers, and must have a positive length between 1 and the length of \texttt{vec}. These correspond to the elements of \texttt{vec} you would like to exclude.\\
  \item
    \textbf{logical elements}: When using the logical strategy we use a vector \texttt{index} which contains only logical (\texttt{TRUE/FALSE}) values. In this strategy \texttt{index} must be the same length as the vector \texttt{vec}. If it is not, R will use \emph{recycling} to complete the command. The \texttt{TRUE} values in \texttt{index} represent the elements of \texttt{vec} you wish to keep, and \texttt{FALSE} values represent the elements you wish to exclude.
  \item
    \textbf{names}: If \texttt{vec} is a named vector we can also use the names to preform indexing. In this case the vector \texttt{index} should be a character vector where each element of the vector is the name of an element in \texttt{vec} that we wish to keep. We can not use a negative operator, or a negative sign with this strategy to exclude variables.
  \end{itemize}
\end{itemize}

We can not mix and max these strategies within a command. We can only use one strategy at a time.

\hypertarget{example-positive-integers}{%
\subsection*{Example: Positive Integers}\label{example-positive-integers}}
\addcontentsline{toc}{subsection}{Example: Positive Integers}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtaining a single element}
\NormalTok{vec[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtaining several elements: Get 1st, 2nd, 3rd element}
\NormalTok{vec[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  9 74 76
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Get mutliples of the same element}
\NormalTok{index <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 76 74  9  9  9 74 76
\end{verbatim}

\hypertarget{example-negative-integers}{%
\subsection*{Example: Negative Integers}\label{example-negative-integers}}
\addcontentsline{toc}{subsection}{Example: Negative Integers}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Remove first element}
\NormalTok{vec[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Remove several elements: 1st, 2nd, 3rd}
\NormalTok{vec[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 55 72 54 39 83 88 15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Equivalent to above}
\NormalTok{index <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{-2}\NormalTok{, }\DecValTok{-3}\NormalTok{)}
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 55 72 54 39 83 88 15
\end{verbatim}

\hypertarget{example-logical-values}{%
\subsection*{Example: Logical Values}\label{example-logical-values}}
\addcontentsline{toc}{subsection}{Example: Logical Values}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# `index` should be the same length as `vec`}
\NormalTok{index <-}\StringTok{ }\KeywordTok{c}\NormalTok{(T, T, T, T, F, F, F, F, F, T)}
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  9 74 76 55 15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# When `index` is not of the same length as `vec`, we have}
\CommentTok{# recycling Keeps every other element}
\NormalTok{index <-}\StringTok{ }\KeywordTok{c}\NormalTok{(T, F)}
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  9 76 72 39 88
\end{verbatim}

\hypertarget{example-names}{%
\subsection*{Example: Names}\label{example-names}}
\addcontentsline{toc}{subsection}{Example: Names}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Give names to each element in `vec`}
\KeywordTok{names}\NormalTok{(vec) <-}\StringTok{ }\NormalTok{LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}

\CommentTok{# Return Elements: A, B, D}
\NormalTok{index <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"D"}\NormalTok{)}
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  A  B  D 
##  9 74 55
\end{verbatim}

\hypertarget{lists-1}{%
\section{Lists}\label{lists-1}}

Although lists are 1D objects, they have three different operators: \texttt{{[}{]}}, \texttt{{[}{[}{]}{]}}, and \texttt{\$}. The first operator works the same way as we saw above for atomic vectors. We can use all four strategies we used in the prior section, and a new list will appear according to the indexing order. The new operators are \texttt{{[}{[}{]}{]}} and \texttt{\$}, these operators are very similar. They both can only isolate one element in the list, and they return this element in its particular class. That is, if the second element in the list is data frame, then a data frame is returned with the \texttt{{[}{[}{]}{]}} and \texttt{\$} operators.

\hypertarget{double-brackets}{%
\subsection{Double Brackets}\label{double-brackets}}

With the double brackets operator \texttt{{[}{[}index{]}{]}} we can put the index number for the element we want returned, or if we have a named list, we can put the name of the element we desire. Remember, you can only isolate one element in the list using this operator, so \texttt{index} must be of length 1.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a named list Recall: name = value}
\NormalTok{lst1 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{first =} \KeywordTok{c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"Goodbye"}\NormalTok{), }\DataTypeTok{second =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{,}
    \DecValTok{3}\NormalTok{), }\DataTypeTok{third =} \KeywordTok{c}\NormalTok{(T, F, T))}

\CommentTok{# Create a nested list with names}
\NormalTok{lst2 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{e1 =}\NormalTok{ lst1, }\DataTypeTok{e2 =} \StringTok{"Stat 107 Rules"}\NormalTok{)}

\CommentTok{# See structure of the list}
\KeywordTok{str}\NormalTok{(lst2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 2
##  $ e1:List of 3
##   ..$ first : chr [1:2] "Hello" "Goodbye"
##   ..$ second: num [1:3] 1 2 3
##   ..$ third : logi [1:3] TRUE FALSE TRUE
##  $ e2: chr "Stat 107 Rules"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate second element by name (maintains class of the}
\CommentTok{# element)}
\NormalTok{lst2[[}\StringTok{"e2"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Stat 107 Rules"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(lst2[[}\StringTok{"e2"}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate second element by integer (maintains class of the}
\CommentTok{# element)}
\NormalTok{lst2[[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Stat 107 Rules"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(lst2[[}\DecValTok{2}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate nested elements}
\NormalTok{lst2[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\hypertarget{dollar-sign}{%
\subsection{Dollar Sign}\label{dollar-sign}}

After the dollar sign operator \texttt{\$} we put the name of the desired element. You can only isolate one element in the list using this operator, and you can only access elements using their names. However, if you have

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate second element by name (maintains class of the}
\CommentTok{# element)}
\NormalTok{lst2}\OperatorTok{$}\NormalTok{e2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Stat 107 Rules"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate nested elements}
\NormalTok{lst2}\OperatorTok{$}\NormalTok{e1}\OperatorTok{$}\NormalTok{second}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

You can also mix and match indexing methods for lists.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst1}\OperatorTok{$}\NormalTok{second[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\hypertarget{matrices-1}{%
\section{Matrices}\label{matrices-1}}

For matrices we will only consider three indexing techniques, these are by far the most popular. There is only one operator we need to consider for matrices, and it is the same one we use for vectors \texttt{{[}{]}}. Inside this operator you can put in two vectors, or a single vector.

\hypertarget{two-vectors}{%
\subsection{Two Vectors}\label{two-vectors}}

Using two vectors when indexing a list is by far the most common, and the recommended way to index a matrix. It is easy to read, and standard practice. For this technique you use \texttt{{[}row,\ column{]}}, where \texttt{row} is a vector of index values of the rows you wish to isolate, and \texttt{column} is a vector of the index values of the columns you wish to isolate. The vectors \texttt{row} and \texttt{column} support positive integers, negative integers, logical vectors, and character vectors with row and column names. That is, we can index the rows and columns of a matrix in the same way we did before with standard vectors, but now we have two dimensions to consider. Like before, the vectors \texttt{row} and \texttt{column} must be all positive values, all negative values, all logical, or only contain the respective names. However, the values between vectors can differ. For example, \texttt{row} can be a vector of positive integers, and \texttt{column} can be a vector of logical values. In general, a matrix returns another matrix, or it returns a vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\KeywordTok{colnames}\NormalTok{(my_m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"C1"}\NormalTok{, }\StringTok{"C2"}\NormalTok{, }\StringTok{"C3"}\NormalTok{)}
\NormalTok{my_m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      C1 C2 C3
## [1,]  1  4  7
## [2,]  2  5  8
## [3,]  3  6  9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtain a full row}
\NormalTok{my_m[}\DecValTok{1}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## C1 C2 C3 
##  1  4  7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Obtain a full column}
\NormalTok{my_m[, }\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# All rows but the first, and get the last two columns}
\NormalTok{my_m[}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"C2"}\NormalTok{, }\StringTok{"C3"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      C2 C3
## [1,]  5  8
## [2,]  6  9
\end{verbatim}

\hypertarget{single-vector}{%
\subsection{Single Vector}\label{single-vector}}

Matrices can be thought of as a special shaped atomic vector where the first elements of the vector are the first column (from top to bottom), the next elements are the second column (top to bottom), and so on. In fact, R supports indexing matrices using this idea. If attempt to subset a matrix using \texttt{{[}index{]}}, where \texttt{index} is a single vector, then the values of \texttt{index} will correspond register the values of the matrix in this order.

It is not particularly common to index in this way, and not recommended because it is not particularly clear.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_m[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_m[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_m[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 3 4 5 6 7 8
\end{verbatim}

\hypertarget{data-frames-1}{%
\section{Data frames}\label{data-frames-1}}

Data frames can be indexed in all the ways that matrices can be indexed above. They also have a few more techniques. At its core, can think of data frames as a special type of list in which each element of the list is a vector of the same length. Data frames have three indexing operators \texttt{{[}{]}}, \texttt{{[}{[}{]}{]}}, and \texttt{\$}. The \texttt{{[}{]}} operator works identically for data frames, as it does matrices, that is we can supply this operator two vectors \texttt{{[}row,\ column{]}} or one \texttt{{[}index{]}}. Thus, we will focus on the other two operators. Recall from indexing lists that \texttt{{[}{[}{]}{]}} and \texttt{\$} can only access one element of a list. When using \texttt{{[}{[}{]}{]}} and \texttt{\$} on data frames these operators can only access one \emph{column}.

\hypertarget{example-double-brackets}{%
\subsection*{Example: Double brackets}\label{example-double-brackets}}
\addcontentsline{toc}{subsection}{Example: Double brackets}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use Built In Data Set: Iris}
\KeywordTok{head}\NormalTok{(iris)  }\CommentTok{# Preview Data Set}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(iris, class)  }\CommentTok{# Class of Each Column }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##    "numeric"    "numeric"    "numeric"    "numeric"     "factor"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(iris)  }\CommentTok{# Summary Statistics of Each Column }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  
##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  
##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  
##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  
##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  
##        Species  
##  setosa    :50  
##  versicolor:50  
##  virginica :50  
##                 
##                 
## 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate column with positive integer Returns a vector,}
\CommentTok{# not a data frame with one column}
\NormalTok{iris[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1
##  [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0
##  [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5
##  [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1
##  [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5
##  [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3
## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8
## [145] 6.7 6.7 6.3 6.5 6.2 5.9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate column with name (Same as above) Returns a}
\CommentTok{# vector, not a data frame with one column}
\NormalTok{iris[[}\StringTok{"Sepal.Length"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1
##  [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0
##  [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5
##  [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1
##  [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5
##  [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3
## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8
## [145] 6.7 6.7 6.3 6.5 6.2 5.9
\end{verbatim}

\hypertarget{example-dollar-sign}{%
\subsection*{Example: Dollar Sign}\label{example-dollar-sign}}
\addcontentsline{toc}{subsection}{Example: Dollar Sign}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Isolate column with name (Same as above) Returns a}
\CommentTok{# vector, not a data frame with one column}
\NormalTok{iris}\OperatorTok{$}\NormalTok{Sepal.Length}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1
##  [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0
##  [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5
##  [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1
##  [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5
##  [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3
## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8
## [145] 6.7 6.7 6.3 6.5 6.2 5.9
\end{verbatim}

\hypertarget{features-and-applications}{%
\section{Features and Applications}\label{features-and-applications}}

In this section we will go over some features and applications of using indexing techniques. These are special functions and things that we can do with the indexing we dicussed so far.

\hypertarget{indexing-and-reassignment}{%
\subsection{Indexing and Reassignment}\label{indexing-and-reassignment}}

Recall the vector \texttt{vec} we created above. With all of the indexing techniques we discussed before, we can combine indexing with reassignment. We can reassign values inside of a vector via their index number. This can be done with all the objects and techniques we have learned. For example, recall the vector \texttt{vec} we created above. We can reassign the first three elements of \texttt{vec} to be 62.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# `vec` from above Generate a random vector with the}
\CommentTok{# following code}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{vec <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)  }\CommentTok{# numeric vector with 10 values}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  9 74 76 55 72 54 39 83 88 15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# reassign first three values of vec using index}
\NormalTok{vec[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{62}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 62 62 62 55 72 54 39 83 88 15
\end{verbatim}

The only values that are changed are the ones we isolated via indexing. Lets see another example with logical values. In this example we use the logical indexing technique to isolate only values that meet a certain condition. So the vector \texttt{index\_to\_change} contains logical values where \texttt{TRUE} indicates that the values in \texttt{vec} are greater than 50, and \texttt{FALSE} if otherwise. So when we use \texttt{vec\_chr{[}index\_to\_change{]}} it changes all elements which correspond to \texttt{TRUE} to be equal to \texttt{Big}. It does not update any other elements in the vector \texttt{vec\_chr}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Make a character vector}
\NormalTok{vec_chr <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(vec)}

\CommentTok{# Reassign elements to 'Big' if they are a big number Do}
\CommentTok{# not change other elements}
\NormalTok{index_to_change <-}\StringTok{ }\NormalTok{vec }\OperatorTok{>}\StringTok{ }\DecValTok{50}
\NormalTok{vec_chr[index_to_change] <-}\StringTok{ "Big"}
\NormalTok{vec_chr}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Big" "Big" "Big" "Big" "Big" "Big" "39"  "Big" "Big" "15"
\end{verbatim}

Here is another example where we reassign a column name of the matrix \texttt{my\_m} to be ``my\_c2''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Recall matrix}
\NormalTok{my_m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      C1 C2 C3
## [1,]  1  4  7
## [2,]  2  5  8
## [3,]  3  6  9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Reassign just one column name}
\KeywordTok{colnames}\NormalTok{(my_m)[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "my_c2"}
\end{Highlighting}
\end{Shaded}

Now lets reassign the value in the second row, second column to be \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_m[}\DecValTok{2}\NormalTok{, }\StringTok{"my_c2"}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{my_m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      C1 my_c2 C3
## [1,]  1     4  7
## [2,]  2    NA  8
## [3,]  3     6  9
\end{verbatim}

\hypertarget{orderinginteger-indexing}{%
\subsection{Ordering/Integer Indexing}\label{orderinginteger-indexing}}

As we saw above, we can also using indexing with positive integers and names to rearrange values in an object. If we want to do a rearrangement based on smallest to largest value (or vice versa), or alphabetical (or reverse alphabetical), we can do this directly with the \texttt{order()} function. This function returns the ranks of the variable being sorted.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example data frame}
\NormalTok{group <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"G1"}\NormalTok{, }\StringTok{"G2"}\NormalTok{, }\StringTok{"G1"}\NormalTok{, }\StringTok{"G1"}\NormalTok{, }\StringTok{"G2"}\NormalTok{)}
\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\NormalTok{height <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{65}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{72}\NormalTok{, }\DecValTok{68}\NormalTok{)}
\NormalTok{pets <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{mydata <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(group, age, height, pets)}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 2    G2  30     70  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
## 5    G2  40     68  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Indices in smallest to largest order}
\KeywordTok{order}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{age)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 2 3 1 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Rearrange data frame to be from shortest to tallest}
\NormalTok{mydata[}\KeywordTok{order}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{age), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 4    G1  28     72 FALSE
## 2    G2  30     70  TRUE
## 3    G1  31     60 FALSE
## 1    G1  35     65  TRUE
## 5    G2  40     68  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydata[}\KeywordTok{order}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{group, mydata}\OperatorTok{$}\NormalTok{age), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 4    G1  28     72 FALSE
## 3    G1  31     60 FALSE
## 1    G1  35     65  TRUE
## 2    G2  30     70  TRUE
## 5    G2  40     68  TRUE
\end{verbatim}

We can sort by more than one variable. Including more than one variable allows a ``nested sort,'' where the second variable, third variable, etc., is used when there are ties in the sorting based on the previous variables. Let's first sort by \texttt{group} alone, and then by \texttt{group} followed by \texttt{age} and see what we get.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sort just by 'group'}
\NormalTok{mydata[}\KeywordTok{order}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{group), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
## 2    G2  30     70  TRUE
## 5    G2  40     68  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Rearrange data frame FIRST by 'group', SECOND by 'age'}
\NormalTok{mydata[}\KeywordTok{order}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{group, mydata}\OperatorTok{$}\NormalTok{age), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 4    G1  28     72 FALSE
## 3    G1  31     60 FALSE
## 1    G1  35     65  TRUE
## 2    G2  30     70  TRUE
## 5    G2  40     68  TRUE
\end{verbatim}

To reorder a vector from smallest to largest we can also consider the \texttt{sort()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sort}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{age)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 28 30 31 35 40
\end{verbatim}

\hypertarget{adding-elementsrowscolumns}{%
\subsection{Adding Elements/Rows/Columns}\label{adding-elementsrowscolumns}}

To add an element/row/column to an object we can also use indexing and the assignment operator. To do so, we put the new index number or index name with our indexing operator, and assign a value. This only works when the new index number is only one more then current length or dimensions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Adding an element to vec}
\NormalTok{vec[}\KeywordTok{length}\NormalTok{(vec) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{] <-}\StringTok{ }\DecValTok{1000}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   62   62   62   55   72   54   39   83   88   15 1000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Adding a column to data frame Iris}
\NormalTok{iris}\OperatorTok{$}\NormalTok{new_column <-}\StringTok{ "Hello"}
\NormalTok{iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, ]  }\CommentTok{# Output first ten rows to preview }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_column
## 1           5.1         3.5          1.4         0.2  setosa      Hello
## 2           4.9         3.0          1.4         0.2  setosa      Hello
## 3           4.7         3.2          1.3         0.2  setosa      Hello
## 4           4.6         3.1          1.5         0.2  setosa      Hello
## 5           5.0         3.6          1.4         0.2  setosa      Hello
## 6           5.4         3.9          1.7         0.4  setosa      Hello
## 7           4.6         3.4          1.4         0.3  setosa      Hello
## 8           5.0         3.4          1.5         0.2  setosa      Hello
## 9           4.4         2.9          1.4         0.2  setosa      Hello
## 10          4.9         3.1          1.5         0.1  setosa      Hello
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Adding another new column to Iris}
\NormalTok{iris[, (}\KeywordTok{ncol}\NormalTok{(iris) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)] <-}\StringTok{ "Goodby"}
\NormalTok{iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, ]  }\CommentTok{# Output first ten rows to preview }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_column     V7
## 1           5.1         3.5          1.4         0.2  setosa      Hello Goodby
## 2           4.9         3.0          1.4         0.2  setosa      Hello Goodby
## 3           4.7         3.2          1.3         0.2  setosa      Hello Goodby
## 4           4.6         3.1          1.5         0.2  setosa      Hello Goodby
## 5           5.0         3.6          1.4         0.2  setosa      Hello Goodby
## 6           5.4         3.9          1.7         0.4  setosa      Hello Goodby
## 7           4.6         3.4          1.4         0.3  setosa      Hello Goodby
## 8           5.0         3.4          1.5         0.2  setosa      Hello Goodby
## 9           4.4         2.9          1.4         0.2  setosa      Hello Goodby
## 10          4.9         3.1          1.5         0.1  setosa      Hello Goodby
\end{verbatim}

\hypertarget{delete-elementsrowscolumns}{%
\subsection{Delete Elements/Rows/Columns}\label{delete-elementsrowscolumns}}

If we wanted to completely delete a element in a vector we can use the assignment operator.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Recall the vector}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   62   62   62   55   72   54   39   83   88   15 1000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec_copy <-}\StringTok{ }\NormalTok{vec}

\CommentTok{# Strategy 2 - Redefine Object: Delete the third element of}
\CommentTok{# vec}
\NormalTok{vec_copy <-}\StringTok{ }\NormalTok{vec_copy[}\OperatorTok{-}\DecValTok{3}\NormalTok{]}
\NormalTok{vec_copy}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   62   62   55   72   54   39   83   88   15 1000
\end{verbatim}

This method also works the same way with 2D objects and lists. In addition we can also use \texttt{NULL}. Recall that \texttt{NULL} is used to completely delete an object, in contrast to \texttt{NA}, which removes the value but saves the space.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Strategy 1 - NULL: Delete a column}
\NormalTok{iris}\OperatorTok{$}\NormalTok{new_column <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, ]  }\CommentTok{# Preview first 10 rows }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species     V7
## 1           5.1         3.5          1.4         0.2  setosa Goodby
## 2           4.9         3.0          1.4         0.2  setosa Goodby
## 3           4.7         3.2          1.3         0.2  setosa Goodby
## 4           4.6         3.1          1.5         0.2  setosa Goodby
## 5           5.0         3.6          1.4         0.2  setosa Goodby
## 6           5.4         3.9          1.7         0.4  setosa Goodby
## 7           4.6         3.4          1.4         0.3  setosa Goodby
## 8           5.0         3.4          1.5         0.2  setosa Goodby
## 9           4.4         2.9          1.4         0.2  setosa Goodby
## 10          4.9         3.1          1.5         0.1  setosa Goodby
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Strategy 2 - Redefine Object: Delete a column}
\NormalTok{iris <-}\StringTok{ }\NormalTok{iris[, }\OperatorTok{-}\KeywordTok{ncol}\NormalTok{(iris)]}
\NormalTok{iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, ]  }\CommentTok{# Preview first 10 rows }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
\end{verbatim}

\hypertarget{select-based-on-condition}{%
\subsection{Select Based on Condition}\label{select-based-on-condition}}

So far we have not used logical vectors to index that much yet. Logical indexing is actually very helpful and common! One of the big reasons we use logical vectors for indexing is to select elements that meet a certain condition. For example, maybe we want only want to display elements of a vector that are larger than 50.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# diplays elements of vec that are larger than 50}
\NormalTok{vec[vec }\OperatorTok{>}\StringTok{ }\DecValTok{50}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   62   62   62   55   72   54   83   88 1000
\end{verbatim}

We can also reassignment elements of a vector that meet a certain condition. This uses ideas from 5.5.1.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Reassign values in vec2 to be NA if they are greater than}
\CommentTok{# 50.}
\NormalTok{vec2 <-}\StringTok{ }\NormalTok{vec}
\NormalTok{vec2[vec2 }\OperatorTok{>}\StringTok{ }\DecValTok{50}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{vec2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA NA NA NA NA NA 39 NA NA 15 NA
\end{verbatim}

We can of course also use this strategy on all other objects that support the \texttt{{[}{]}} operator, which is everything so far!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# display rows of iris that have species == 'setosa'}
\NormalTok{iris[iris}\OperatorTok{$}\NormalTok{Species }\OperatorTok{==}\StringTok{ "setosa"}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
## 11          5.4         3.7          1.5         0.2  setosa
## 12          4.8         3.4          1.6         0.2  setosa
## 13          4.8         3.0          1.4         0.1  setosa
## 14          4.3         3.0          1.1         0.1  setosa
## 15          5.8         4.0          1.2         0.2  setosa
## 16          5.7         4.4          1.5         0.4  setosa
## 17          5.4         3.9          1.3         0.4  setosa
## 18          5.1         3.5          1.4         0.3  setosa
## 19          5.7         3.8          1.7         0.3  setosa
## 20          5.1         3.8          1.5         0.3  setosa
## 21          5.4         3.4          1.7         0.2  setosa
## 22          5.1         3.7          1.5         0.4  setosa
## 23          4.6         3.6          1.0         0.2  setosa
## 24          5.1         3.3          1.7         0.5  setosa
## 25          4.8         3.4          1.9         0.2  setosa
## 26          5.0         3.0          1.6         0.2  setosa
## 27          5.0         3.4          1.6         0.4  setosa
## 28          5.2         3.5          1.5         0.2  setosa
## 29          5.2         3.4          1.4         0.2  setosa
## 30          4.7         3.2          1.6         0.2  setosa
## 31          4.8         3.1          1.6         0.2  setosa
## 32          5.4         3.4          1.5         0.4  setosa
## 33          5.2         4.1          1.5         0.1  setosa
## 34          5.5         4.2          1.4         0.2  setosa
## 35          4.9         3.1          1.5         0.2  setosa
## 36          5.0         3.2          1.2         0.2  setosa
## 37          5.5         3.5          1.3         0.2  setosa
## 38          4.9         3.6          1.4         0.1  setosa
## 39          4.4         3.0          1.3         0.2  setosa
## 40          5.1         3.4          1.5         0.2  setosa
## 41          5.0         3.5          1.3         0.3  setosa
## 42          4.5         2.3          1.3         0.3  setosa
## 43          4.4         3.2          1.3         0.2  setosa
## 44          5.0         3.5          1.6         0.6  setosa
## 45          5.1         3.8          1.9         0.4  setosa
## 46          4.8         3.0          1.4         0.3  setosa
## 47          5.1         3.8          1.6         0.2  setosa
## 48          4.6         3.2          1.4         0.2  setosa
## 49          5.3         3.7          1.5         0.2  setosa
## 50          5.0         3.3          1.4         0.2  setosa
\end{verbatim}

\hypertarget{convert-indexing-techniques}{%
\subsection{Convert Indexing Techniques}\label{convert-indexing-techniques}}

With all these methods it can sometimes be difficult to remember which is which. However, we will often find ourselves naturally gravitating to one technique over another. There are different operators and functions in R that help us convert the different techniques. For example, the \texttt{which()} function helps us switch from logical indexing to positive integer indexing.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Switch from logical strategy, to positive integer}
\CommentTok{# strategy}
\NormalTok{index <-}\StringTok{ }\KeywordTok{which}\NormalTok{(vec }\OperatorTok{>}\StringTok{ }\DecValTok{50}\NormalTok{)}
\NormalTok{index}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2  3  4  5  6  8  9 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   62   62   62   55   72   54   83   88 1000
\end{verbatim}

The \texttt{\%in\%} operator helps us make a check if elements in the object \texttt{values} are in the set \texttt{keep}, i.e.~\texttt{values\ \%in\%\ keep}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns logical vector of column names to keep}
\NormalTok{keep <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"species"}\NormalTok{, }\StringTok{"Sepal.Length"}\NormalTok{)}
\KeywordTok{colnames}\NormalTok{(iris) }\OperatorTok{%in%}\StringTok{ }\NormalTok{keep}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE FALSE FALSE
\end{verbatim}

\hypertarget{summary-3}{%
\section*{Summary}\label{summary-3}}
\addcontentsline{toc}{section}{Summary}

\begin{itemize}
\item
  Indexing operators \texttt{{[}{]}}, \texttt{{[}{[}{]}{]}}, \texttt{\$}
\item
  \texttt{{[}{]}}: Used with 1d and 2d objects

  \begin{itemize}
  \tightlist
  \item
    Positive Integers
  \item
    Negative Integers
  \item
    Name
  \item
    Logical
  \end{itemize}
\item
  \texttt{{[}{[}{]}{]}}: Used with lists or Data frames. Can only isolate one element or column.

  \begin{itemize}
  \tightlist
  \item
    Positive Integers
  \item
    Name
  \end{itemize}
\item
  \texttt{\$}: Used with lists or Data frames. Can only isolate one element or column.

  \begin{itemize}
  \tightlist
  \item
    Name
  \end{itemize}
\item
  Indexing can be combined with reassignment.
\item
  Some important functions and operators to remember: \texttt{order()}, \texttt{sort()}, \texttt{which()}, \texttt{\%in\%}.
\end{itemize}

\hypertarget{working-with-data-sets}{%
\chapter{Working with Data Sets}\label{working-with-data-sets}}

In this section we discuss different methods for loading data sets into our R session. There are many different files we can create and import. We will focus our attention on loading csv files because they tend to be easier to import, and they are one of the more typical file types that are used. In the second half of the this chapter we introduce some more basic data manipulation strategies and helpful functions when working with data sets beyond indexing.

\hypertarget{LoadData}{%
\section{Getting Data Sets in Our Working Environment}\label{LoadData}}

\hypertarget{built-in-data}{%
\subsection*{Built-In Data}\label{built-in-data}}
\addcontentsline{toc}{subsection}{Built-In Data}

As discussed last week, there are built in objects which are not loaded into the global environment, but can be called upon at any time. For example \texttt{pi} returns the value 3.1415927. Similarly, there are built in data sets that are ready to be used and loaded at a moments notice.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  To see a list of built in data sets type in the console:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  These data sets can be used even if they are not listed in the global environment. For example, if you would like to load the data set \texttt{cars} in the global environment, run the following command:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(}\StringTok{"cars"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{importing-from-your-computer}{%
\subsection*{Importing From Your Computer}\label{importing-from-your-computer}}
\addcontentsline{toc}{subsection}{Importing From Your Computer}

Although built-in data sets are convient, most the time we need to load our own datasets. We load our own data sets by using a function specifically designed for the file type of interest. This function usually uses the file path location as an argument. This can be done in many different ways; however, we will only go over two.

\textbf{Option 1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Download the file \texttt{InsectData.csv} from \textbf{ELearn}. Save this file in a spot in your computer you will remember.
\item
  In the \textbf{Environment} window (upper left window), click on the \textbf{Import Dataset} button. A drop down menu will appear. Select the \textbf{From Text (base)\ldots{}} option. Find the file \texttt{InsectData.csv} and select it.
\item
  A pop up menu will appear giving you options for loading in the file, and showing a preview of what the file will look like once loaded. Select the appropriate options and click \textbf{Import}.
\item
  A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file.
\end{enumerate}

\textbf{Option 2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Download the file \texttt{InsectData.csv} from \textbf{ELearn}. Save this file in a spot in your computer you will remember.
\item
  In the lower right hand window select the \textbf{File} tab. Now search for the file which you have saved \texttt{InsectData.csv}.
\item
  Click on the file \texttt{InsectData.csv} in order to see a dropdown menu. Select \textbf{Import Dataset\ldots{}}
\item
  A window will appear which will give you options and a preview of your file. Select appropriate options if needed then click \textbf{Import}.
\item
  A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file.
\end{enumerate}

\hypertarget{import-from-online}{%
\subsection*{Import From Online}\label{import-from-online}}
\addcontentsline{toc}{subsection}{Import From Online}

We can also download data sets from online in a variety of different ways. Below is one option. With this method we are using the same \texttt{InsectData.csv} file, but it has been posted online. We feed the url of where the data set has been posted into the \texttt{read.csv()} function in order to open the file.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the_url <-}\StringTok{ "https://raw.githubusercontent.com/rpkgarcia/LearnRBook/main/data_sets/InsectData.csv"}
\NormalTok{the_data <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(the_url)}
\end{Highlighting}
\end{Shaded}

\hypertarget{basic-data-manipulation}{%
\section{Basic Data Manipulation}\label{basic-data-manipulation}}

Lets recall a few useful things about data frames. As we learned already, data sets are contained in an object called a data frame. One can view this as a specialized table or matrix of rows and columns, where each column is a data variable, such as height or age, and each row is a single observation. All of the values within a column must be the same data type (numeric,factor, logical, etc.). Data frames can be created or called within R, imported from text or spreadsheet files, or imported from the web.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{group <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"G1"}\NormalTok{, }\StringTok{"G2"}\NormalTok{, }\StringTok{"G1"}\NormalTok{, }\StringTok{"G1"}\NormalTok{, }\StringTok{"G2"}\NormalTok{)}
\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{28}\NormalTok{, }\DecValTok{40}\NormalTok{)}
\NormalTok{height <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{65}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{72}\NormalTok{, }\DecValTok{68}\NormalTok{)}
\NormalTok{pets <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}

\NormalTok{mydata <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(group, age, height, pets)}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 2    G2  30     70  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
## 5    G2  40     68  TRUE
\end{verbatim}

The \texttt{summary()} function is a powerful command that gives you some summary statistics about the variables in the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(mydata)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     group                age           height      pets        
##  Length:5           Min.   :28.0   Min.   :60   Mode :logical  
##  Class :character   1st Qu.:30.0   1st Qu.:65   FALSE:2        
##  Mode  :character   Median :31.0   Median :68   TRUE :3        
##                     Mean   :32.8   Mean   :67                  
##                     3rd Qu.:35.0   3rd Qu.:70                  
##                     Max.   :40.0   Max.   :72
\end{verbatim}

The summary statistics are listed below the names of the variables. Since pets is a logical variable, R gives you the frequencies of each unique value. In this example there are three values of \texttt{TRUE} and two values of \texttt{FALSE}. Since age and weight are numeric, R computes and returns the minimum, 1st quartile (25th percentile), median, mean, 3rd quartile (75th percentile), and maximum values. If you have many data values, this is a quick way to get a feel for how the data are distributed.

Just like we did for vectors, we can also use the \texttt{table()} to cross-tabulate categorical data. Let's create a frequency table for the different groups.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{group)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## G1 G2 
##  3  2
\end{verbatim}

We can also create a frequency table of pet status for both groups.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(mydata}\OperatorTok{$}\NormalTok{group, mydata}\OperatorTok{$}\NormalTok{pets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     
##      FALSE TRUE
##   G1     2    1
##   G2     0    2
\end{verbatim}

\hypertarget{subset}{%
\subsection*{Subset}\label{subset}}
\addcontentsline{toc}{subsection}{Subset}

We already discussed how powerful indexing techniques can be, and various different ways to use indexing to subset a data set. We also have the \texttt{subset()} function which accomplishes much of the same tasks, and can be used as an alternative to many indexing operations. For example, we can subset a data frame by isolating all rows that belong to group ``G1''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{group1 <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(mydata, mydata}\OperatorTok{$}\NormalTok{group }\OperatorTok{==}\StringTok{ "G1"}\NormalTok{)}
\NormalTok{group1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
\end{verbatim}

To subset by all values which are NOT equal to a condition we can use the logical operator \texttt{!=}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{group2 <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(mydata, mydata}\OperatorTok{$}\NormalTok{group }\OperatorTok{!=}\StringTok{ "G1"}\NormalTok{)}
\NormalTok{group2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height pets
## 2    G2  30     70 TRUE
## 5    G2  40     68 TRUE
\end{verbatim}

\hypertarget{adding-columns}{%
\subsection*{Adding Columns}\label{adding-columns}}
\addcontentsline{toc}{subsection}{Adding Columns}

One can add a new variable (column) to a data frame by defining a new variable and assigning values to it. Below we add a \texttt{weight} variable to the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wghts <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{169}\NormalTok{, }\DecValTok{161}\NormalTok{, }\DecValTok{149}\NormalTok{, }\DecValTok{165}\NormalTok{, }\DecValTok{155}\NormalTok{)}
\NormalTok{wghts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 169 161 149 165 155
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydata}\OperatorTok{$}\NormalTok{weight <-}\StringTok{ }\NormalTok{wghts}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight
## 1    G1  35     65  TRUE    169
## 2    G2  30     70  TRUE    161
## 3    G1  31     60 FALSE    149
## 4    G1  28     72 FALSE    165
## 5    G2  40     68  TRUE    155
\end{verbatim}

We can also add a new column using the \texttt{cbind()} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydata <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(mydata, wghts)}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight wghts
## 1    G1  35     65  TRUE    169   169
## 2    G2  30     70  TRUE    161   161
## 3    G1  31     60 FALSE    149   149
## 4    G1  28     72 FALSE    165   165
## 5    G2  40     68  TRUE    155   155
\end{verbatim}

\hypertarget{na-values}{%
\subsection*{NA values}\label{na-values}}
\addcontentsline{toc}{subsection}{NA values}

In addition, if we have a missing value, or a blank value, we can use the object \texttt{NA} to indicate the lack of a value.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fav_color <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Red"}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\StringTok{"Purple"}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\StringTok{"Red"}\NormalTok{)}

\NormalTok{mydata <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(mydata, fav_color)}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight wghts fav_color
## 1    G1  35     65  TRUE    169   169       Red
## 2    G2  30     70  TRUE    161   161      <NA>
## 3    G1  31     60 FALSE    149   149    Purple
## 4    G1  28     72 FALSE    165   165      <NA>
## 5    G2  40     68  TRUE    155   155       Red
\end{verbatim}

We can drop check for \texttt{NA} values using the \texttt{is.na()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(mydata)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      group   age height  pets weight wghts fav_color
## [1,] FALSE FALSE  FALSE FALSE  FALSE FALSE     FALSE
## [2,] FALSE FALSE  FALSE FALSE  FALSE FALSE      TRUE
## [3,] FALSE FALSE  FALSE FALSE  FALSE FALSE     FALSE
## [4,] FALSE FALSE  FALSE FALSE  FALSE FALSE      TRUE
## [5,] FALSE FALSE  FALSE FALSE  FALSE FALSE     FALSE
\end{verbatim}

We can remove all rows with \texttt{NA} values using \texttt{na.omit()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{na.omit}\NormalTok{(mydata)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight wghts fav_color
## 1    G1  35     65  TRUE    169   169       Red
## 3    G1  31     60 FALSE    149   149    Purple
## 5    G2  40     68  TRUE    155   155       Red
\end{verbatim}

\hypertarget{null}{%
\subsection*{NULL}\label{null}}
\addcontentsline{toc}{subsection}{NULL}

One can drop a variable (column) by setting it equal to the \texttt{R} value \texttt{NULL}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mydata}\OperatorTok{$}\NormalTok{wghts <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{mydata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight fav_color
## 1    G1  35     65  TRUE    169       Red
## 2    G2  30     70  TRUE    161      <NA>
## 3    G1  31     60 FALSE    149    Purple
## 4    G1  28     72 FALSE    165      <NA>
## 5    G2  40     68  TRUE    155       Red
\end{verbatim}

Be careful using these methods. Once a variable or row is dropped, it's gone.

\hypertarget{adding-rows}{%
\subsection*{Adding Rows}\label{adding-rows}}
\addcontentsline{toc}{subsection}{Adding Rows}

Rows can be added to a data frame using the \texttt{rbind()} (row bind) function. Because our columns have different data types, we will create a list object and then add it as a new row.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{newobs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\StringTok{"G1"}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{62}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\DecValTok{160}\NormalTok{, }\StringTok{"Blue"}\NormalTok{)}
\NormalTok{newdata <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(mydata, newobs)}
\NormalTok{newdata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets weight fav_color
## 1    G1  35     65  TRUE    169       Red
## 2    G2  30     70  TRUE    161      <NA>
## 3    G1  31     60 FALSE    149    Purple
## 4    G1  28     72 FALSE    165      <NA>
## 5    G2  40     68  TRUE    155       Red
## 6    G1  23     62 FALSE    160      Blue
\end{verbatim}

We can also use \texttt{rbind()} to append one data frame to another. We can do this with the variables \texttt{group1} and \texttt{group2} created above still exist in your R environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{group1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{group2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height pets
## 2    G2  30     70 TRUE
## 5    G2  40     68 TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rbind}\NormalTok{(group1, group2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   group age height  pets
## 1    G1  35     65  TRUE
## 3    G1  31     60 FALSE
## 4    G1  28     72 FALSE
## 2    G2  30     70  TRUE
## 5    G2  40     68  TRUE
\end{verbatim}

\hypertarget{summary-4}{%
\section*{Summary}\label{summary-4}}
\addcontentsline{toc}{section}{Summary}

\begin{itemize}
\tightlist
\item
  How to get data

  \begin{itemize}
  \tightlist
  \item
    Use default data sets \texttt{data()}
  \item
    Load csv files with \texttt{read.csv()} and \texttt{read\_csv()}
  \item
    Download data from online
  \end{itemize}
\item
  Data manipulation functions to keep in mind

  \begin{itemize}
  \tightlist
  \item
    \texttt{table()}, \texttt{summary()}
  \item
    \texttt{subset()}
  \item
    \texttt{rbind()}, \texttt{cbind()}
  \item
    \texttt{na.omit()}, \texttt{is.na()}
  \end{itemize}
\end{itemize}

\hypertarget{functions}{%
\chapter{Functions}\label{functions}}

In R we have functions, functions are another type of object in R. We use functions in order to preform a series of tasks repeatedly, or preform these tasks in different settings. They can make our code much more efficient. We can build our own functions or we can use built in functions. Here we describe both types and their properties. Parts of this chapter where adapted by \citet{r-func} and \citet{dummies2015}.

\hypertarget{build-your-own-function}{%
\section{Build Your Own Function}\label{build-your-own-function}}

To define a function, a name is assigned and the keyword \texttt{function} is used to denote the start of the function and its argument list. Functions are created using the \texttt{function()} directive and are stored as R objects just like anything else. In particular, they are R objects of class \emph{function}. Functions can be passed as arguments to other functions. Functions can be nested, so that you can define a function inside another function.

Below is the \textbf{general template}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{function_name <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(arg) \{}
    \CommentTok{# Function Body}
\NormalTok{    ....}
    \KeywordTok{return}\NormalTok{(return_value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this template we have the following key components

\begin{itemize}
\tightlist
\item
  \texttt{function\_name}: This is the actual name of the function. It is stored in R environment as an object with this name.
\item
  \texttt{function}: A directive which tells R a function is being created.
\item
  \texttt{arg}: An argument is a placeholder. When a function is invoked, you pass a value to the argument. Arguments are optional; that is, a function may contain no arguments. Also arguments can have default values.
\item
  \texttt{function\ body}: The function body contains a collection of statements that defines what the function does.
\item
  \texttt{return\_value}: The output value of the function. If \texttt{return(return\_value)} is not supplied then the return value of a function is the last expression in the function body to be evaluated. Your function can only return one object. This object can be any class of object you desire, like a vector, list or data frame, but you may only return one object.
\end{itemize}

Below is an example of converting a temperature from Fahrenheit to Celsius.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert temperature from Fahrenheit (F) to Celsius (C)}
\CommentTok{# ARGUMENTS: temp_F, a numeric vector of length 1 in F}
\CommentTok{# units RETURNS: temp_C, a numeric vector of length 1 in C}
\CommentTok{# units}
\NormalTok{fahrenheit_to_celsius <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(temp_F) \{}
\NormalTok{    temp_C =}\StringTok{ }\NormalTok{(temp_F }\OperatorTok{-}\StringTok{ }\DecValTok{32}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{5}\OperatorTok{/}\DecValTok{9}
    \KeywordTok{return}\NormalTok{(temp_C)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this example the function name is \texttt{fahrenheit\_to\_celsius}, there is only one input or argument, \texttt{temp\_F}, and the output is the object \texttt{temp\_C}.

Now if we would like to ``call'' this function we can simply put into the command console the function name and desired input.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Convert 87F to Celsius}
\KeywordTok{fahrenheit_to_celsius}\NormalTok{(}\DataTypeTok{temp_F =} \DecValTok{87}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30.55556
\end{verbatim}

What would happen if we tried to call this function without supplying an input? This would result in an error.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# temp_F not defined.}
\KeywordTok{fahrenheit_to_celsius}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in fahrenheit_to_celsius() : 
  argument "temp_F" is missing, with no default
\end{verbatim}

With functions we can define function arguments to have default values. These default values are used only if the user did not supply an argument value. Observe the example below.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# An example function, does simply algebra ARGUMENTS: a = 1}
\CommentTok{# (default), a numeric vector of length 1 b, a numeric}
\CommentTok{# vector of length 1 RETURNS: d, a numeric vector of length}
\CommentTok{# 1}
\NormalTok{example_func <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, b) \{}
\NormalTok{    c =}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\NormalTok{b}
\NormalTok{    d =}\StringTok{ }\NormalTok{c }\OperatorTok{+}\StringTok{ }\DecValTok{1}

    \CommentTok{# returns a+b+1}
    \KeywordTok{return}\NormalTok{(d)}
\NormalTok{\}}

\CommentTok{# Call example function}
\KeywordTok{example_func}\NormalTok{(}\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example_func}\NormalTok{(}\DataTypeTok{b =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

Further notice that R has three ways to match function inputs to the formal arguments of the function definition. R attempts to match inputs to arguements in the following order.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  by complete name
\item
  by partial name (matching on initial \emph{n} characters of the argument name)
\item
  by position
\end{enumerate}

After running a function command R first attempts to match arguments by complete name, then by partial name, and then by position. If it unable to match inputs to an argument it then uses the default argument value, if one exists.

Observe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example_func}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example_func}\NormalTok{(}\DataTypeTok{b =} \DecValTok{3}\NormalTok{, }\DataTypeTok{a =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example_func}\NormalTok{(}\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\hypertarget{lexical-scoping}{%
\section{Lexical Scoping}\label{lexical-scoping}}

With all these examples of functions, notice that in your global environment, only the function name was added. The function arguments, return values, and all objects defined inside the function are not a part of the global environment. This is not a mistake. We can define objects locally, or temporarily, when using functions. These objects are created and used only when the function is running, and quickly discarded once the function finishes. They never are listed in the global environment.

Sometimes you may have an object defined in multiple places. When this happens, R uses a system of rules to determine which definition it will use. In other words, how and where we define an object determines the objects \emph{scope}, or range of places that we can use this object. The system of rules R uses for searching for objects is called \emph{lexical scoping}, as opposed to other types of scoping. With this system R looks for objects that are called in a function within the itself, then any enclosing environments, then the global environment, and lastly looking at objects in packages or built-in objects. This is the same searching method that we see in Python and Java.

\begin{center}\includegraphics[width=36.5in]{images/Scoping} \end{center}

\hypertarget{built-in-functions}{%
\section{Built-In Functions}\label{built-in-functions}}

R has functions built-in to it just like excel. You can call these built-in function at any time. We have already seen a few of these functions.

\begin{itemize}
\tightlist
\item
  \texttt{c()}
\item
  \texttt{class()}
\item
  \texttt{matrix()}
\item
  \texttt{data.frame()}
\end{itemize}

Below are a few more examples using the built-in dataset \texttt{mtcars}, we will use \texttt{mtcars\$mpg} as a vector of data to analyze.

\begin{itemize}
\tightlist
\item
  \texttt{mean()}: Takes in a vector, and returns the mean of the values in the vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20.09062
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{median()}: Takes in a vector, and returns the median of the values in the vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{median}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 19.2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{var()}: Takes in a vector, and returns the variance of the values in the vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 36.3241
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{sqrt()}: If you give it a vector, it returns the square root of each element in the vector. If you give it a single number, it returns the square root of the number.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 4.582576 4.582576 4.774935 4.626013 4.324350 4.254409 3.781534 4.939636
##  [9] 4.774935 4.381780 4.219005 4.049691 4.159327 3.898718 3.224903 3.224903
## [17] 3.834058 5.692100 5.513620 5.822371 4.636809 3.937004 3.898718 3.646917
## [25] 4.381780 5.224940 5.099020 5.513620 3.974921 4.438468 3.872983 4.626013
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{sd()}: Takes in a vector, and returns the standard deviation of the values in the vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sd}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.026948
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{range()}: Takes in a vector, and returns the minimum AND maximum of the values in the vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{range}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10.4 33.9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{quantile()}: Takes in a vector as the first argument, and a vector of values between 0 and 1 (any number of values) for the second argument. It will return the corresponding quantiles of the values in the first vector specified by the second vector.
\end{itemize}

To get the \(10^{th}\) and \(90^{th}\) percentiles:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quantile}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg, }\KeywordTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.9}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   10%   90% 
## 14.34 30.09
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{summary()}: You can give this a dataset OR a vector. It returns some summary information about the values in the dataset or vector.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(cars}\OperatorTok{$}\NormalTok{speed)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     4.0    12.0    15.0    15.4    19.0    25.0
\end{verbatim}

One of the great advantages of using R is that there is a ton of resources available to learn about it. However, this can also be a disadvantage because of the vast amount of information available. The best and first resource you should look at when trying learn more about R functions is the \textbf{Help files}.

\hypertarget{vectorization}{%
\section{Vectorization}\label{vectorization}}

\hypertarget{help-files}{%
\section{Help Files}\label{help-files}}

The Help files are in R and can be viewed from the lower right window by clicking the \emph{Help} tab. Here you can search by function name to read about it. Each built in function has a help files, sometimes similar functions are grouped together in the same file. The R Help Files are typically the best resource to get help.

The R Help files follow a fairly standard outline. You find most of the following sections in every R Help file:

\begin{itemize}
\item
  \textbf{Title}: A one-sentence overview of the function.
\item
  \textbf{Description}: An introduction to the high-level objectives of the function, typically about one paragraph long.
\item
  \textbf{Usage}: A description of the syntax of the function (in other words, how the function is called). This is where you find all the arguments that you can supply to the function, as well as any default values of these arguments.
\item
  \textbf{Arguments}: A description of each argument. Usually this includes a specification of the class (for example, character, numeric, list, and so on). This section is an important one to understand, because arguments are frequently a cause of errors in R.
\item
  \textbf{Details}: Extended details about how the function works, provides longer descriptions of the various ways to call the function (if applicable), and a longer discussion of the arguments.
\item
  \textbf{Value}: A description of the class of the value returned by the function.
\item
  \textbf{See also}: Links to other relevant functions. In most of the R editors, you can click these links to read the Help files for these functions.
\item
  \textbf{Examples}: Worked examples of real R code that you can paste into your console and run.
\end{itemize}

An alternative way to view a functions help file is by typing \texttt{?} followed by the function name, or by typing \texttt{help(function\_name)}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Find a help file for the function `rep`}
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(rep)}
\KeywordTok{help}\NormalTok{(rep)}
\end{Highlighting}
\end{Shaded}

If you are not sure exactly which function you want, you can use \texttt{??} followed by what you believe the function name is to look at a list of functions.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(rep))}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-argument}{%
\section{The \ldots{} Argument}\label{the-argument}}

There is a special argument function \texttt{...} that can be used. Sometimes we call a function within a function that has a different set of arguments. We can use the \texttt{...} argument as a general placeholder for passing along any additional arguments in a function call.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# An example function, uses the ... argument and calls}
\CommentTok{# fun2() ARGUMENTS: x , a numeric vector of length 1 ...,}
\CommentTok{# all additional arguments to be passed to fun2() RETURNS:}
\CommentTok{# z, a numeric vector of length 1}
\NormalTok{fun1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    y =}\StringTok{ }\KeywordTok{fun2}\NormalTok{(...)}
\NormalTok{    z =}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
    \KeywordTok{return}\NormalTok{(z)}
\NormalTok{\}}

\CommentTok{# Support function for fun1() ARGUMENTS: a , a numeric}
\CommentTok{# vector of length 1 RETURNS: b, a numeric vector of length}
\CommentTok{# 1}
\NormalTok{fun2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a) \{}
\NormalTok{    b =}\StringTok{ }\NormalTok{a}\OperatorTok{^}\DecValTok{2}
    \KeywordTok{return}\NormalTok{(b)}
\NormalTok{\}}

\CommentTok{# Returns 1 + 2^2 = 5}
\KeywordTok{fun1}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

We can also use the \texttt{...} argument in a nested fashion.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# An example function, uses the ... argument and calls}
\CommentTok{# fun2() ARGUMENTS: x , a numeric vector of length 1 ...,}
\CommentTok{# all additional arguments to be passed to fun2() RETURNS:}
\CommentTok{# z, a numeric vector of length 1}
\NormalTok{fun1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    y =}\StringTok{ }\KeywordTok{fun2}\NormalTok{(...)}
\NormalTok{    z =}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
    \KeywordTok{return}\NormalTok{(z)}
\NormalTok{\}}

\CommentTok{# Support function for fun1(), calls fun3() ARGUMENTS: a ,}
\CommentTok{# a numeric vector of length 1 ..., all additional}
\CommentTok{# arguments to be passed to fun3() RETURNS: c, a numeric}
\CommentTok{# vector of length 1}
\NormalTok{fun2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, ...) \{}
\NormalTok{    b =}\StringTok{ }\KeywordTok{fun3}\NormalTok{(...)}
\NormalTok{    c =}\StringTok{ }\NormalTok{a}\OperatorTok{^}\DecValTok{2} \OperatorTok{+}\StringTok{ }\NormalTok{b}
    \KeywordTok{return}\NormalTok{(c)}
\NormalTok{\}}

\CommentTok{# Support function for fun1() and fun2(), called by fun2()}
\CommentTok{# ARGUMENTS: n , a numeric vector of length 1 RETURNS: n, a}
\CommentTok{# numeric vector of length 1}
\NormalTok{fun3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{    n =}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(n)}
    \KeywordTok{return}\NormalTok{(n)}
\NormalTok{\}}

\CommentTok{# Returns: 1 + 2^2 + sqrt(4) = 7}
\KeywordTok{fun1}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns: 1 + 2^2 + sqrt(4) = 7 Define each input}
\CommentTok{# explicitly}
\KeywordTok{fun1}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{n =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

When using the \texttt{...} argument it is customary to always place \texttt{...} at the end of a function argument list, as it can be difficult for R to determine which arguments are to be passed to the next function. If possible, it is good practice to explicitly define the arguments to avoid an error.

\hypertarget{generic-functions}{%
\section{Generic Functions}\label{generic-functions}}

In R we have something called \emph{generic functions} which are functions that behave differently depending on the class type of one of the arguments. Typically generic functions depend on the class of the first argument. The functions \texttt{mean()}, \texttt{summary()}, and \texttt{plot()} are all generic functions. These functions act as a ``middle man'' or a ``dispatcher''. The generic function calls the actual function you desire. For example, when we call \texttt{summary()} and the first argument is a \texttt{lm} object, then the summary function that is actually run is \texttt{summary.lm()} which may have its own help file.

\hypertarget{additional-resources-3}{%
\section*{Additional Resources}\label{additional-resources-3}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  \href{https://bookdown.org/rdpeng/rprogdatascience/functions.html\#the-...-argument}{Chapter 14 of ``R for Programming in Data Science''}
\item
  \href{https://adv-r.hadley.nz/s3.html}{Chapter 13 of ``Advanced R''}
\item
  Videos:

  \begin{itemize}
  \tightlist
  \item
    \href{https://ucr.yuja.com/V/Video?v=2390137\&node=8588230\&a=1409376127\&autoplay=1}{R Functions 1 \textbar{} Anatomy of a Function}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368890\&node=8488096\&a=1477744713\&autoplay=1}{R Functions 2 \textbar{} Getting Help}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368889\&node=8488095\&a=762120086\&autoplay=1}{R Functions 3 \textbar{} Argument Order and Default Values}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2700489\&node=9649685\&a=1404409900\&autoplay=1}{Writing Functions 1 \textbar{} Introduction}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2700492\&node=9649688\&a=604881114\&autoplay=1}{Writing Functions 2 \textbar{} 4 Fundamental Steps}
  \end{itemize}
\end{itemize}

\hypertarget{packages}{%
\chapter{Packages}\label{packages}}

\texttt{R} packages are a collection of \texttt{R} functions, complied code and sample data. They are stored under a directory called ``library'' in the \texttt{R} environment. By default, \texttt{R} installs a set of packages during installation. More packages are added later, when they are needed for some specific purpose. When we start the \texttt{R} console, only the default packages are available by default. Other packages which are already installed have to be loaded explicitly to be used by the \texttt{R} program that is going to use them.

All the packages available in \texttt{R} language are listed at \href{https://cran.r-project.org/web/packages/available_packages_by_name.html}{R Packages}.

To see a list of all packages installed on your device.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

To see a list of all packages that are currently loaded (note that yours will likely look different).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{search}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] ".GlobalEnv"        "package:knitr"     "package:stats"    
##  [4] "package:graphics"  "package:grDevices" "package:utils"    
##  [7] "package:datasets"  "package:methods"   "Autoloads"        
## [10] "package:base"
\end{verbatim}

When adding a new package to our library we only have to install it once. We can do so with the following command.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"library name"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Alternatively, we can also go to the lower left hand window and select the \emph{Packages} tab. Then hit the button \textbf{Install}. A dropdown menu will appear where we can search for the package name.

Before a package can be used in the code, it must be loaded to the current R environment. You also need to load a package that is already installed previously but not available in the current environment.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"library name"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

For example, suppose we wanted to install and load the package ``ggplot2'', (a very popular package for making plots). We would type the following commands.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Install package (only need to do this once)}
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}

\CommentTok{# Load into working environment (need to do this for each}
\CommentTok{# new R session)}
\KeywordTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It might seem strange to (1) have to download packages tto use features and (2) have to load these packages each time we wish to use them; however, there are several good reasons for doing packages in this way, and this system is considered a feature. We don't have all possible packages available to us at all times because that is a lot of information that R would need to store at once which could make our computer lag. These packages are also always being updated at different rates with different features. Most users will only utilize packages in CRAN, so having to update R each session for features you may never use would be tedious. Furthermore, there are several packages which contain objects and functions with the same name.

\hypertarget{namespace-collisions}{%
\section{Namespace Collisions}\label{namespace-collisions}}

Every time we load a package into our environment the results for the \texttt{search()} function changes. The most recently added package is always listed after the global environment, followed by the second most recent, and so on.
The \texttt{search()} function tells us how R searches for an object that we called. For example, consider the following command.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

In this case R is searching for the function mean first in the global environment, and then in the package in the order that appears in the output of the \texttt{search()} function. The package \texttt{base} is always last. In our case the function \texttt{mean()} is only defined in the base package. If you want to call a function from a specific package explicitly and want to be sure there is no confusion you can type the package name followed by \texttt{::} and the desired command.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{base}\OperatorTok{::}\KeywordTok{mean}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

This can be useful, but is not usually necessary.

\hypertarget{if-statements}{%
\chapter{If Statements}\label{if-statements}}

If statements are a type of control flow structure. Control structures help us control how many times code is executed, and when it will be executed. This is helpful because sometime we only want our program to run if certain conditions are met.

\hypertarget{if}{%
\section{If}\label{if}}

In R we can also execute commands only if certain conditions are met using the \texttt{if} operator. This feature in R checks a logical value (\texttt{\textless{}value\textgreater{}}) and if it is \texttt{TRUE} then a sequence of commands within \texttt{\{\}} will be ran. If \texttt{\textless{}value\textgreater{}} is \texttt{FALSE}, then the commands inside of \texttt{\{\}} will not be ran.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(}\OperatorTok{<}\NormalTok{value}\OperatorTok{>}\NormalTok{)\{}
  \CommentTok{# Commands }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Below we have an example. The code will only be executed if \texttt{x} is a positive number.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{3}

\ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "positive"}
\NormalTok{\}}
\NormalTok{type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "positive"
\end{verbatim}

In the example above we have a relational operator which returns a logical value. This logical value was equal to \texttt{TRUE} so the code was executed.

\hypertarget{if-else}{%
\section{If Else}\label{if-else}}

We can pair an \texttt{if} statement with an \texttt{else} value. After the \texttt{else} object we can define another sequence of commands inside of \texttt{\{\}}. The \texttt{else} value is paired with the immediate previous \texttt{if} statement. If this \texttt{if} statement is \texttt{FALSE} then the \texttt{else} code will run. If the \texttt{if} statement is \texttt{TRUE} then the \texttt{else} code will not be executed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{-3}

\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{class}\NormalTok{(x) }\OperatorTok{==}\StringTok{ "numeric"}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "number"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    type =}\StringTok{ "not a number"}
\NormalTok{\}}
\NormalTok{type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "number"
\end{verbatim}

\hypertarget{else-if}{%
\section{Else If}\label{else-if}}

Sometimes we will want to do a sequence of checks that are all related, and we will only want code to run if the previous \texttt{if} statements were \texttt{FALSE} and another criteria is \texttt{TRUE}. We can use \texttt{else\ if} to implement these rules.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{-3}


\ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "positive"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "negative"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "zero"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    type =}\StringTok{ "Error"}
\NormalTok{\}}

\NormalTok{type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "negative"
\end{verbatim}

The command for the \texttt{if} statement will only run if \texttt{x\textgreater{}0}, and the rest of the code will not be implemented.

The first \texttt{else\ if} commands will only execute if the first \texttt{if} statement was \texttt{FALSE} and \texttt{x\textless{}0}.

The second \texttt{else\ if} commands will only execute if the previous \texttt{else\ if} and \texttt{if} statements were \texttt{FALSE} and \texttt{x==0}.

If the previous \texttt{if} statement and all previous \texttt{else\ if} statements are \texttt{FALSE} then the \texttt{else} code will be executed.

Here is another example with an \texttt{if\ else} chain.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Toyfun <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(X, Y, Do) \{}
    \ControlFlowTok{if}\NormalTok{ (Do }\OperatorTok{==}\StringTok{ "Add"}\NormalTok{) \{}
\NormalTok{        Z =}\StringTok{ }\NormalTok{X }\OperatorTok{+}\StringTok{ }\NormalTok{Y}

\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (Do }\OperatorTok{==}\StringTok{ "Subtract"}\NormalTok{) \{}
\NormalTok{        Z =}\StringTok{ }\NormalTok{X }\OperatorTok{-}\StringTok{ }\NormalTok{Y}

\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (Do }\OperatorTok{==}\StringTok{ "Multiply"}\NormalTok{) \{}
\NormalTok{        Z =}\StringTok{ }\NormalTok{X }\OperatorTok{*}\StringTok{ }\NormalTok{Y}

\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (Do }\OperatorTok{==}\StringTok{ "Penguin"}\NormalTok{) \{}
\NormalTok{        Z =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"<('' )"}\NormalTok{)}

\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        Z =}\StringTok{ }\KeywordTok{c}\NormalTok{(X, Y)}
\NormalTok{    \}}

    \KeywordTok{return}\NormalTok{(Z)}
\NormalTok{\}}
\KeywordTok{Toyfun}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\StringTok{"Add"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Toyfun}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\StringTok{"Subtract"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Toyfun}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\StringTok{"Penguin"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<('' )"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Toyfun}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\StringTok{"Typo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4
\end{verbatim}

\hypertarget{ifelse}{%
\section{Ifelse}\label{ifelse}}

We have a shortcut function that can help us keep our code more succinct using the \texttt{ifelse()} function. The first argument of this function is a logical value. the second and third arguments are what to do if the value is \texttt{TRUE} or \texttt{FALSE}, respectively.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{3}
\NormalTok{type <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{, }\StringTok{"positive"}\NormalTok{, }\StringTok{"nonpositive"}\NormalTok{)}
\NormalTok{type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "positive"
\end{verbatim}

We can also pass \texttt{ifelse()} a vector, and it will check the logical condition for each element of the vector. For example, in the \texttt{mtcars} data set, we can find the proportion of cars have \texttt{mpg\ \textgreater{}\ 25} and \texttt{hp\ \textgreater{}\ 60}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fast_efficient <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg }\OperatorTok{>}\StringTok{ }\DecValTok{25} \OperatorTok{&}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{hp }\OperatorTok{>}\StringTok{ }\DecValTok{60}\NormalTok{, }\OtherTok{TRUE}\NormalTok{,}
    \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{sum}\NormalTok{(fast_efficient)}\OperatorTok{/}\KeywordTok{length}\NormalTok{(fast_efficient)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.15625
\end{verbatim}

\hypertarget{nested-if-chains}{%
\section{Nested If Chains}\label{nested-if-chains}}

We can make \texttt{if-else} chains nested within each other.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{105}
\ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{100}\NormalTok{) \{}
\NormalTok{        type =}\StringTok{ "large positive number"}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        type =}\StringTok{ "positive number"}
\NormalTok{    \}}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "negative number"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    type =}\StringTok{ "zero"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    type =}\StringTok{ "Error"}
\NormalTok{\}}

\NormalTok{type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "large positive number"
\end{verbatim}

\hypertarget{additional-resources-4}{%
\section*{Additional Resources}\label{additional-resources-4}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  \href{https://bookdown.org/rdpeng/rprogdatascience/functions.html\#the-...-argument}{Chapter 13 of ``R for Programming in Data Science''}
\item
  Videos:

  \begin{itemize}
  \tightlist
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369005\&node=8488277\&a=1089164180\&autoplay=1}{Control Flow 1 \textbar{} if Statements}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369004\&node=8488276\&a=68950775\&autoplay=1}{Control Flow 2 \textbar{} if else Statements}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369003\&node=8488275\&a=577245814\&autoplay=1}{Control Flow 3 \textbar{} else if Statements}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369002\&node=8488274\&a=2043700498\&autoplay=1}{Control Flow 4 \textbar{} ifelse Function}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369001\&node=8488273\&a=523725749\&autoplay=1}{Control Flow 5 \textbar{} switch Function}
  \end{itemize}
\end{itemize}

\hypertarget{base-r-plotting}{%
\chapter{Base R Plotting}\label{base-r-plotting}}

\hypertarget{load-a-big-data-set}{%
\section{Load A Big Data Set}\label{load-a-big-data-set}}

Let use some of the methods above, and others, to analyze a real data set. The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, their HIV/AIDS status, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site (\url{http://www.cdc.gov/brfss}) contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. We will focus on a random sample of 20,000 people from the BRFSS survey conducted in the year 2000. While there are over 200 variables in this data set, we will work with a smaller subset.

We begin by loading the data set of 20,000 observations into the R workspace and examine some of its attributes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{source}\NormalTok{(}\StringTok{"http://www.openintro.org/stat/data/cdc.R"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

After a brief time, a new data frame cdc appears in the workspace. Each row representing a case (a person surveyed) and each column representing a variable.

To get general information on each variable, use the \texttt{summary()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(cdc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       genhlth        exerany          hlthplan         smoke100     
##  excellent:4657   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  
##  very good:6972   1st Qu.:0.0000   1st Qu.:1.0000   1st Qu.:0.0000  
##  good     :5675   Median :1.0000   Median :1.0000   Median :0.0000  
##  fair     :2019   Mean   :0.7457   Mean   :0.8738   Mean   :0.4721  
##  poor     : 677   3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:1.0000  
##                   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  
##      height          weight         wtdesire          age        gender   
##  Min.   :48.00   Min.   : 68.0   Min.   : 68.0   Min.   :18.00   m: 9569  
##  1st Qu.:64.00   1st Qu.:140.0   1st Qu.:130.0   1st Qu.:31.00   f:10431  
##  Median :67.00   Median :165.0   Median :150.0   Median :43.00            
##  Mean   :67.18   Mean   :169.7   Mean   :155.1   Mean   :45.07            
##  3rd Qu.:70.00   3rd Qu.:190.0   3rd Qu.:175.0   3rd Qu.:57.00            
##  Max.   :93.00   Max.   :500.0   Max.   :680.0   Max.   :99.00
\end{verbatim}

The variables \texttt{genhlth} and \texttt{gender} are character variables. The \texttt{summary()} command reports the frequencies of the unique values. The variables \texttt{exerany}, \texttt{hlthplan}, and \texttt{smoke100} are yes/no variables coded as 1=yes or 0=no. They represent the existence or absence or regular exercise, the presence of a healthcare plan, and whether or not the person smoked 100 cigarettes in their lifetime. The means are the proportion of ``yes'' responses. The variables \texttt{height}, \texttt{weight}, \texttt{wtdesire}, and \texttt{age} are numeric variables. The \texttt{summary()} command gives information on the means, medians, quartiles and range of values.

Since this is a very large data set, we wouldn't want to list all the data. We can use the functions \texttt{head()} and \texttt{tail()} to list the first and last few rows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(cdc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     genhlth exerany hlthplan smoke100 height weight wtdesire age gender
## 1      good       0        1        0     70    175      175  77      m
## 2      good       0        1        1     64    125      115  33      f
## 3      good       1        1        1     60    105      105  49      f
## 4      good       1        1        0     66    132      124  42      f
## 5 very good       0        1        0     61    150      130  55      f
## 6 very good       1        1        0     64    114      114  55      f
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tail}\NormalTok{(cdc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         genhlth exerany hlthplan smoke100 height weight wtdesire age gender
## 19995      good       0        1        1     69    224      224  73      m
## 19996      good       1        1        0     66    215      140  23      f
## 19997 excellent       0        1        0     73    200      185  35      m
## 19998      poor       0        1        0     65    216      150  57      f
## 19999      good       1        1        0     67    165      165  81      f
## 20000      good       1        1        1     69    170      165  83      m
\end{verbatim}

\hypertarget{histograms}{%
\section{Histograms}\label{histograms}}

Histograms are one of the fundamental ways that we can represent a data set. In a histogram we typically have the frequency or proportion on the y-axis, and the x-axis is segmented into mutually exclusive sections. The height of the bins corresponds to amount of observations that fall within a specific range. We can create a histogram using the \texttt{hist()} function.

Most of the basic R plots have default settings. For example, the x-axis, y-axis, number of bins, titles, and labels all change depending on the vector supplied into the function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Look at the help file}
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(hist)}


\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-170-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-170-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{age)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-170-3.pdf}

The output appears in the \emph{Plots} panel of \emph{RStudio}. You can use the arrows to the left of the \emph{Zoom} button the switch among the three plots.

There are several settings in base R plots that are similar. For example, in base R plots typically we can change the title, x-axis label, and y-axis label with \texttt{main}, \texttt{xlab}, and \texttt{ylab} arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{main =} \StringTok{"Distribution of Weight"}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"Weight (kg)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-171-1.pdf}

There are also function specific arguments. For example, we can control the number of bins to create.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{main =} \StringTok{"Distribution of Weight"}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"Weight (kg)"}\NormalTok{,}
    \DataTypeTok{breaks =} \DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-172-1.pdf}

Use \texttt{col} argument to change the colors used for the bars. By using the \texttt{border} argument, you can even change the color used for the border of the bars.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{breaks =} \DecValTok{20}\NormalTok{, }\DataTypeTok{main =} \StringTok{"Distribution of Weight"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Weight (kg)"}\NormalTok{, }\DataTypeTok{border =} \StringTok{"mediumpurple4"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"mediumpurple1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-173-1.pdf}

There are several ways we can add \textbf{colors} to \texttt{R}.

\begin{itemize}
\item
  \textbf{Using Color Names}: \texttt{R} programming has names for 657 colors. You can take a look at them all with the \texttt{colors()} function, or simply check this R color pdf.
\item
  \textbf{Using Hex Values as Colors}: Instead of using a color name, color can also be defined with a hexadecimal value. We define a color as a 6 hexadecimal digit number of the form \texttt{\#RRGGBB}. Where the \texttt{RR} is for red, \texttt{GG} for green and \texttt{BB} for blue and value ranges from \texttt{00} to \texttt{FF}. For example, \texttt{\#FF0000} would be red and \texttt{\#00FF00} would be green similarly, \#FFFFFF would be white and \texttt{\#000000} would be black.
\item
  \textbf{Using RGB Values} The function \texttt{rgb()} allows us to specify red, green and blue component with a number between 0 and 1. This function returns the corresponding hex code discussed above.
\item
  \textbf{Using a Color Palette}: R programming offers 5 built in color palettes which can be used to quickly generate color vectors of desired length. They are: \texttt{rainbow()}, \texttt{heat.colors()}, \texttt{terrain.colors()}, \texttt{topo.colors()} and \texttt{cm.colors()}. We pass in the number of colors that we want
\end{itemize}

You can also place values on top of bars; which will help you interpret the graph correctly. You can add them by setting the labels argument to \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height[}\DecValTok{1}\OperatorTok{:}\DecValTok{1000}\NormalTok{], }\DataTypeTok{col =} \StringTok{"dodgerblue3"}\NormalTok{, }\DataTypeTok{labels =} \OtherTok{TRUE}\NormalTok{,}
    \DataTypeTok{ylim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{200}\NormalTok{), }\DataTypeTok{breaks =} \DecValTok{18}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-174-1.pdf}

Often you want to compare the distributions of different variables within your data. You can overlay the histograms by setting the \texttt{add} argument of the second histogram to \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# random numbers}
\NormalTok{h1 <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{h2 <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{4}\NormalTok{)}

\CommentTok{# Overlay two histograms}
\KeywordTok{hist}\NormalTok{(h1, }\DataTypeTok{col =} \KeywordTok{rgb}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FloatTok{0.25}\NormalTok{))}
\KeywordTok{hist}\NormalTok{(h2, }\DataTypeTok{col =} \KeywordTok{rgb}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.25}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-175-1.pdf}

For more options, look up ``hist'' in the \emph{Help} panel of \emph{RStudio}.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(hist)}
\end{Highlighting}
\end{Shaded}

\hypertarget{boxplot}{%
\section{Boxplot}\label{boxplot}}

Let's produce a boxplot for the first 1000 values of the height variable.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{boxplot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height[}\DecValTok{1}\OperatorTok{:}\DecValTok{1000}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-177-1.pdf}

The line in the center is the median. The bottom and top of the box are drawn at the first (\(Q_1\)) and third (\(Q_3\)) quartiles (same as the 25th and 75th percentiles). The difference between the third and first quartiles is called the interquartile range (\(Q_3-Q_1\)). This is the height of the box. The lines above and below the box are called the whiskers. The upper whisker is either the third quartile plus 1.5 times the interquartile range, \(Q3 +1.5(Q_3-Q_1)\), or the largest data value, whichever is smallest. Similarly, the lower whisker is either the first quartile minus 1.5 times the interquartile range, \(Q1-1.5(Q_3-Q_1)\), or the smallest data value, whichever is largest. If data values exceed the whiskers, they are considered outliers (according to the \(IQR\) method, see Homework 2) and are plotted as circles. Boxplots are often used to represent numeric data.

One can use boxplots to compare different groups using \texttt{\textasciitilde{}} character. On the right side of \texttt{\textasciitilde{}} is the numeric variable, and the left side of \texttt{\textasciitilde{}} is a grouping variable (character, logical, factor).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{boxplot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height[}\DecValTok{1}\OperatorTok{:}\DecValTok{1000}\NormalTok{] }\OperatorTok{~}\StringTok{ }\NormalTok{cdc}\OperatorTok{$}\NormalTok{gender[}\DecValTok{1}\OperatorTok{:}\DecValTok{1000}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-178-1.pdf}

\hypertarget{scatter-plot}{%
\section{Scatter Plot}\label{scatter-plot}}

We can create a scatter plot using the \texttt{plot()} function in R. This is generic function, which means that it will behave differently depending on the inputted values. For now we will on creating a simple \(X\) vs \(Y\) plot, which is what we typically want.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Help file for the GENERIC function}
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(plot)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Help on topic 'plot' was found in the following packages:
## 
##   Package               Library
##   graphics              /Library/Frameworks/R.framework/Versions/4.0/Resources/library
##   base                  /Library/Frameworks/R.framework/Resources/library
## 
## 
## Using the first match ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Help file for plot when using a simple X vs Y input}
\StringTok{`}\DataTypeTok{?}\StringTok{`}\NormalTok{(plot.default)}

\CommentTok{# Run the command}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-179-1.pdf}

Notice that this help file has many of the same arguments as we saw with the \texttt{hist()} function. For example, \texttt{xlab}, \texttt{ylab}, \texttt{main}, and \texttt{col}. A lot of Base R plotting functions are related and use the same techniques and arguments.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Plot using HEX color system}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \StringTok{"#33F3FF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-180-1.pdf}
Other interesting features we may want to consider is having different colors points on our plot. We can supple the \texttt{col} argument for a vector the colors we want plotted. If the vector of is the same length as the number of rows in our data set, then the index of the vector of colors corresponds to the index of the point being plotted. If the vector of colors is not the size, then colors are generated using recycling. For example, below only two colors were supplied. This means every other point in the data set had a different color.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Plot using HEX color system}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \KeywordTok{c}\NormalTok{(}\StringTok{"#33F3FF"}\NormalTok{, }\StringTok{"#A833FF"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-181-1.pdf}
There are lots of other features we can change. Consider changing \texttt{cex}, \texttt{type}, \texttt{bg}, \texttt{pch}, \texttt{ylim}, \texttt{xlim}.

\hypertarget{pie-charts}{%
\section{Pie Charts}\label{pie-charts}}

We will now look at some of the qualitative data that are not numbers, but categories or groups. The \texttt{table()} function can be used to tabulate categorical data. The \texttt{genhlth} variable has five categories, we can use \texttt{table()} to find the frequencies.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{genhlth)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## excellent very good      good      fair      poor 
##      4657      6972      5675      2019       677
\end{verbatim}

Since the sample size is 20,000, we can divide by n to get proportions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{genhlth)}\OperatorTok{/}\DecValTok{20000}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## excellent very good      good      fair      poor 
##   0.23285   0.34860   0.28375   0.10095   0.03385
\end{verbatim}

Pie charts are also used for categorical data. Options are also available for the \texttt{pie()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pie}\NormalTok{(}\KeywordTok{table}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{genhlth)}\OperatorTok{/}\DecValTok{20000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-184-1.pdf}

Options are also available for the pie() function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{colors =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"green"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"yellow"}\NormalTok{, }\StringTok{"pink"}\NormalTok{, }\StringTok{"red"}\NormalTok{)}
\KeywordTok{pie}\NormalTok{(}\KeywordTok{table}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{genhlth)}\OperatorTok{/}\DecValTok{20000}\NormalTok{, }\DataTypeTok{col =}\NormalTok{ colors, }\DataTypeTok{main =} \StringTok{"General Health"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-185-1.pdf}

\hypertarget{adding-straight-lines}{%
\section{Adding Straight Lines}\label{adding-straight-lines}}

Often you want to draw attention to specific values or observations in your graphic to provide unique insight. You can do this by adding markers to your graphic. For example, adding mean line will give you an idea about how much of the distribution is above and below the average. You can add such marker by using the \texttt{abline()} function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on a histogram}
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{breaks =} \DecValTok{20}\NormalTok{, }\DataTypeTok{main =} \StringTok{"Distribution of Weight"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Weight (kg)"}\NormalTok{, }\DataTypeTok{border =} \StringTok{"mediumpurple4"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"mediumpurple1"}\NormalTok{)}

\KeywordTok{abline}\NormalTok{(}\DataTypeTok{v =} \KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"mediumblue"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-186-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on scatter plot}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \StringTok{"darkblue"}\NormalTok{)}

\CommentTok{# Make a solid line}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{h =} \KeywordTok{median}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}

\CommentTok{# Make a dashed line}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{h =} \KeywordTok{median}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{wtdesire), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-187-1.pdf}

\hypertarget{adding-lines-between-points}{%
\section{Adding Lines Between Points}\label{adding-lines-between-points}}

Sometimes, we would rather add a line connecting two points, rather than a continuous vertical, horizontal or linear line. To do this we can use the \texttt{lines()} function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on scatter plot}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \StringTok{"darkblue"}\NormalTok{)}

\CommentTok{# Add a line connecting two points.}
\KeywordTok{lines}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{55}\NormalTok{, }\DecValTok{84}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{400}\NormalTok{, }\DecValTok{200}\NormalTok{), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}

\CommentTok{# Add a line connecting a series of points}
\KeywordTok{lines}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{50}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{350}\NormalTok{, }\DecValTok{225}\NormalTok{, }\DecValTok{300}\NormalTok{, }\DecValTok{425}\NormalTok{),}
    \DataTypeTok{col =} \StringTok{"green"}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-188-1.pdf}

\hypertarget{adding-individual-points}{%
\section{Adding Individual Points}\label{adding-individual-points}}

Similarly we can also add points to any base R graph using the \texttt{points()} function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on scatter plot}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \StringTok{"darkblue"}\NormalTok{)}

\CommentTok{# Make a solid line}
\KeywordTok{points}\NormalTok{(}\KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height), }\KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}

\CommentTok{# Sample random points to plot}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{62}\NormalTok{)}
\NormalTok{random_index =}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(cdc), }\DecValTok{20}\NormalTok{)}
\KeywordTok{points}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height[random_index], cdc}\OperatorTok{$}\NormalTok{weight[random_index], }\DataTypeTok{col =} \StringTok{"yellow"}\NormalTok{,}
    \DataTypeTok{pch =} \DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-189-1.pdf}

In the \texttt{points()} help file we can see a separate section called \texttt{pch\ values} which contains the different types of points that Base R can create.

Notice that the \texttt{abline()} function had arguments \texttt{lty}, and \texttt{lwd}. In addition, the \texttt{points()} function had the arguments \texttt{cex} and \texttt{bg}. The description for these arguments is in the \texttt{par} help file which contains a master set of graphical parameter arguments. In this file we can also see that \texttt{main}, \texttt{xlab}, and \texttt{ylab} are also listed.

\hypertarget{the-par-help-file}{%
\section{The par() Help File}\label{the-par-help-file}}

The \texttt{par} file contains graphical arguments that are common in base R graphics functions. We can look inside this help file for even more arguments that may not be listed in the Base R plotting functions like \texttt{hist()}, \texttt{plot()}, \texttt{points()}, and \texttt{abline()}.

It is also a function that can adjust global plotting window parameters. For example, suppose we wish to have multiple plots on plotting window. We can control this with \texttt{mfrow}. When adjusting global plotting parameters it is best to always revert back to the default settings when you are done.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Change plot window to have 3 columns and 1 row of plots}
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\CommentTok{# Three plots in one window}
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height)}
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight)}
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{age)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-190-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Revert back to default}
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-legends}{%
\section{Adding Legends}\label{adding-legends}}

We can also consider adding a legend to our new graph using the \texttt{legend()} function. This function lets us put our own unique labels on different plotting aspects we created. Note that the function arguments like \texttt{col}, \texttt{lty}, and \texttt{pch} are used to dictate what should be on the legend.

We control were the legend goes by using the first argument. This first argument \texttt{x} can be the the location on the x-axis, or it can be a keyword such as: ``bottomright'', ``bottom'', ``bottomleft'', ``left'', ``topleft'', ``top'', ``topright'', ``right'' and ``center''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on a histogram}
\KeywordTok{hist}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{breaks =} \DecValTok{20}\NormalTok{, }\DataTypeTok{main =} \StringTok{"Distribution of Weight"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Weight (kg)"}\NormalTok{, }\DataTypeTok{border =} \StringTok{"mediumpurple4"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"mediumpurple1"}\NormalTok{)}

\KeywordTok{abline}\NormalTok{(}\DataTypeTok{v =} \KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"mediumblue"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}

\KeywordTok{legend}\NormalTok{(}\StringTok{"topright"}\NormalTok{, }\DataTypeTok{legend =} \KeywordTok{c}\NormalTok{(}\StringTok{"Mean Weight"}\NormalTok{), }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{col =} \StringTok{"mediumblue"}\NormalTok{,}
    \DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-191-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add a line on scatter plot}
\KeywordTok{plot}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height, cdc}\OperatorTok{$}\NormalTok{weight, }\DataTypeTok{xlab =} \StringTok{"Height"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Weight"}\NormalTok{,}
    \DataTypeTok{col =} \StringTok{"darkblue"}\NormalTok{)}

\CommentTok{# Make a solid line}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{h =} \KeywordTok{median}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}

\CommentTok{# Add a single point}
\KeywordTok{points}\NormalTok{(}\KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height), }\KeywordTok{mean}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{weight), }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}

\CommentTok{# Sample random points to plot}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{62}\NormalTok{)}
\NormalTok{random_index =}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(cdc), }\DecValTok{20}\NormalTok{)}
\KeywordTok{points}\NormalTok{(cdc}\OperatorTok{$}\NormalTok{height[random_index], cdc}\OperatorTok{$}\NormalTok{weight[random_index], }\DataTypeTok{col =} \StringTok{"orange"}\NormalTok{,}
    \DataTypeTok{pch =} \DecValTok{8}\NormalTok{)}

\CommentTok{# Make a legend}
\KeywordTok{legend}\NormalTok{(}\StringTok{"topleft"}\NormalTok{, }\DataTypeTok{legend =} \KeywordTok{c}\NormalTok{(}\StringTok{"All Data Values"}\NormalTok{, }\StringTok{"Mean"}\NormalTok{, }\StringTok{"Sample"}\NormalTok{,}
    \StringTok{"Median Weight"}\NormalTok{), }\DataTypeTok{pch =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{8}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{col =} \KeywordTok{c}\NormalTok{(}\StringTok{"darkblue"}\NormalTok{,}
    \StringTok{"red"}\NormalTok{, }\StringTok{"orange"}\NormalTok{, }\StringTok{"red"}\NormalTok{), }\DataTypeTok{lty =} \KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-192-1.pdf}

\hypertarget{what-makes-a-good-plot}{%
\section{What makes a good plot?}\label{what-makes-a-good-plot}}

It takes practice both to create and identify good plots. In general plots should have the following properties.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  \textbf{Informative Title}: A title should contain a concise description of what is being plotted. In general, when thinking of a title consider including: who, what, when, where, why, and how. Depending the context and audience you might not need all of these elements. For instance, if you have a standard scatter plot, you do not necessarily need to list ``Scatter Plot''. This font should be larger compared to other text on the plot. The title should fit comfortably on the figure.
\item
  \textbf{Appropriately Labeled Axis}: Use appropriate axis labels. Instead of simply saying ``X'' or ``Y'', say what the variables of these axises are. Include the units of measurement on theses axis labels. Use correct capitalization and punctuation. Make sure the font is reasonably sized. A rule of thumb is for it to be about half the size of the title font. Make sure tick marks and unit intervals on an axis are consistent and appropriate for the scale.
\item
  \textbf{Nothing Cutoff}: Points, lines, titles, labels, text should all fit comfortably on the plot. There should not be excessive white space, and we should not have values so zoomed in that we cannot see other points. With particularly large data sets we can consider taking a simple random sample, and only plotting those points for ease of readability.
\item
  \textbf{Units of measurement listed}: Include units of measurement for the different axises, and for additional graphical parameters as necessary.
\item
  \textbf{Legends (when applicable)}: Legends should be included if elements of the plot differ by different variables. Legends can be within the plotting area, or outside of the plotting area. Legends can vary greatly depending on the context. Often times the legend font is smaller than else where on the plot.
\item
  \textbf{Communicate a Clear Message}: When creating plots it can be tempting to make the plot be too generic or add several elements. Try to have one clear message and objective when creating a plot. Make sure to know your audience. That will also dictate how much you can communicate, and what level of detail needs to be included.
\end{enumerate}

This is not an exhaustive list, but contains a general quick check list of items to consider when creating plots. What constituents a ``bad'' plot and a ``good'' plot can be subjective. Use your best judgment and be creative.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length, iris}\OperatorTok{$}\NormalTok{Petal.Length, }\DataTypeTok{col =} \KeywordTok{factor}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Species),}
    \DataTypeTok{pch =} \KeywordTok{as.integer}\NormalTok{(}\KeywordTok{factor}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Species)), }\DataTypeTok{main =} \StringTok{"Anderson's Iris Data (1935): Sepal Length vs Petal Length"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Sepal Length (cm)"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"Petal Length (cm)"}\NormalTok{)}

\KeywordTok{legend}\NormalTok{(}\StringTok{"bottomright"}\NormalTok{, }\DataTypeTok{legend =} \KeywordTok{c}\NormalTok{(}\StringTok{"Setosa"}\NormalTok{, }\StringTok{"Versicolor"}\NormalTok{, }\StringTok{"Virginica"}\NormalTok{),}
    \DataTypeTok{col =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), }\DataTypeTok{pch =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-193-1.pdf}

\hypertarget{extending-base-r-graphics}{%
\chapter{Extending Base R Graphics}\label{extending-base-r-graphics}}

Base R Graphics can be greatly extended. There are several packages, functions, and features that we can add to our standard graphics.

\hypertarget{the-maps-package}{%
\section{The ``maps'' Package}\label{the-maps-package}}

Base R plotting is very powerful and has many features. However, sometimes you want to create something specialized or create a more unique type of plot. There are a lot of plotting tools that can be added to base R plots by using packages. Packages are covered in more detail in Section \ref{packages}.

We specifically consider the \texttt{maps} package which lets us create different types of maps in R. The most important function in this package is the function \texttt{map()}. This function generates various types of maps depending on the inputted values. If we input nothing, then the function defaults to creating a map of the world with lines dividing the different countries.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(maps)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: package 'maps' was built under R version 4.0.2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-194-1.pdf}

The first argument for the function \texttt{map()} is called \texttt{database}. This argument is expecting a character vector of length 1. The element in this vector corresponds to the map you want to create. As we saw above, the default for this package is to create a world map, this corresponds to when argument is \texttt{database=\ "world"}. The values this argument can support are: ``world'', ``usa'', ``state'', and ``county''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{# world map}
\KeywordTok{map}\NormalTok{(}\StringTok{"world"}\NormalTok{)}

\CommentTok{# USA map}
\KeywordTok{map}\NormalTok{(}\StringTok{"usa"}\NormalTok{)}
\KeywordTok{map}\NormalTok{(}\StringTok{"state"}\NormalTok{)}
\KeywordTok{map}\NormalTok{(}\StringTok{"county"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-195-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Within these maps we can specify specific regions that we may want plotted. In general, it supports the names of countries, and states in the US. To specify a region to be plotted we use the \texttt{region} argument, which is the second argument of the function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\KeywordTok{map}\NormalTok{(}\StringTok{"world"}\NormalTok{, }\DataTypeTok{regions =} \StringTok{"Switzerland"}\NormalTok{)}
\KeywordTok{map}\NormalTok{(}\StringTok{"state"}\NormalTok{, }\DataTypeTok{regions =} \StringTok{"oklahoma"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-196-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

These functions have some of the same features of our normal Base R functions. For example, we can still add points and lines to these graphs, but now we have to do it in the correct coordinate system.

For example, we can plot the locations of world cities that are capitals using the data set \texttt{world.cities} which is part of the \texttt{maps} package using the base R plot function \texttt{points()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map}\NormalTok{(}\StringTok{"world"}\NormalTok{)}
\NormalTok{captial_cities =}\StringTok{ }\NormalTok{world.cities[world.cities}\OperatorTok{$}\NormalTok{capital }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{, ]}
\KeywordTok{points}\NormalTok{(captial_cities}\OperatorTok{$}\NormalTok{long, captial_cities}\OperatorTok{$}\NormalTok{lat, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-197-1.pdf}

The maps package does not use the standard base R label arguments like \texttt{main,\ xlab,\ ylab}. However, if we wish to have a map with labels we can use the function \texttt{map.text()} instead of \texttt{map()}. This is essentially the same function as \texttt{map()}, but it defaults to labeling the graph for us. If we want to add our own custom label we use the \texttt{labels} argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{# Default Label}
\KeywordTok{map.text}\NormalTok{(}\StringTok{"world"}\NormalTok{, }\DataTypeTok{regions =} \StringTok{"Switzerland"}\NormalTok{)}

\CommentTok{# Custom Label}
\KeywordTok{map.text}\NormalTok{(}\StringTok{"state"}\NormalTok{, }\DataTypeTok{regions =} \StringTok{"oklahoma"}\NormalTok{, }\DataTypeTok{labels =} \StringTok{"Custom Label Here"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-198-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{some-additional-packages-to-consider}{%
\section{Some additional Packages to consider}\label{some-additional-packages-to-consider}}

Extend Fonts and Colors

\begin{itemize}
\item
  \href{https://cran.r-project.org/web/packages/showtext/}{showtext}: Extend the fonts of R
\item
  \href{https://cran.r-project.org/web/packages/emojifont/}{emojis}: Add emojis to plots.
\item
  \href{https://cran.r-project.org/web/packages/viridis/index.html}{viridis}: Color palettes for common forms of color blindness and/or color vision deficiency.
\item
  \href{https://cran.r-project.org/web/packages/RColorBrewer/index.html}{RColorBrewer}: Color palettes particularly common for maps.
\item
  \href{https://cran.r-project.org/web/packages/wesanderson/index.html}{wesanderson}: Color palettes generated mostly from `Wes Anderson' movies.
\end{itemize}

More Plot Formats

\begin{itemize}
\item
  \href{https://cran.r-project.org/web/packages/corrplot/}{corrplot}: Provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables.
\item
  \href{https://cran.r-project.org/web/packages/heatmap3/}{heatmp}: Create heat maps.
\item
  \href{https://cran.r-project.org/web/packages/riverplot/}{riverplot}: Implements Sankey or Ribbon plots.
\item
  \href{https://cran.r-project.org/web/packages/sinaplot/}{sinaplot}: Creates enhanced jitter strip chart, where the width of the jitter is controlled by the density distribution of the data within each class.
\item
  \href{https://cran.r-project.org/web/packages/vcd/}{vcd}: Visualization techniques, data sets, summary and inference procedures aimed particularly at categorical data.
\item
  \href{https://cran.r-project.org/web/packages/visreg/}{visreg}: If you know about linear regression, you can use this make advanced linear regression plots.
\item
  \href{https://cran.r-project.org/web/packages/vioplot/index.html}{vioplot}: Creates violin plots which are a combination of a box plot and a density plot (density plots look kinda like histograms).
\end{itemize}

For even more packages that extend Base R graphics: \url{https://blog.insileco.io/wiki/rgraphpkgs/}

\hypertarget{loops}{%
\chapter{Loops}\label{loops}}

Loops are another type of control flow structure. They dictate how many times a series of commands should be run. There are two type of loops, a \texttt{while} loop and a \texttt{for} loop. These two loops operate similarly and are found in other programming languages such as \texttt{C} and \texttt{Python}.

\hypertarget{while-loop}{%
\section{While Loop}\label{while-loop}}

A \texttt{while} loop is used when you want to perform a task indefinitely, until a particular condition is met. It's a condition-controlled loop.

\begin{center}\includegraphics[width=14.5in]{images/WhileLoop} \end{center}

The loop will continue until the condition is \texttt{FALSE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{5}

\CommentTok{# If statement is true, keep running the loop}
\ControlFlowTok{while}\NormalTok{ (x }\OperatorTok{!=}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
## [1] 4
## [1] 3
## [1] 2
## [1] 1
\end{verbatim}

If the condition is false at the start, the while loop will never be executed at all.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\DecValTok{0}

\CommentTok{# If statement starts as TRUE, the loop will never run}
\ControlFlowTok{while}\NormalTok{ (x }\OperatorTok{!=}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{for-loops}{%
\section{For Loops}\label{for-loops}}

The \texttt{for} statement in R is a bit different from what you usually use in other programming languages. Rather than iterating over a numeric progression, R's \texttt{for} statement iterates over the items of a vector or a list. The items are iterated in the order that they appear in the vector.

\begin{center}\includegraphics[width=16.11in]{images/ForLoop} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Iterate through a vector}
\NormalTok{colors <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"green"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"yellow"}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ colors) \{}
    \KeywordTok{print}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "red"
## [1] "green"
## [1] "blue"
## [1] "yellow"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\FloatTok{3.14}\NormalTok{, }\StringTok{"Hi"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ lst) \{}
    \KeywordTok{print}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.14
## [1] "Hi"
## [1] 1 2 3
\end{verbatim}

If you need to execute a group of statements for a specified number of times, use sequence operator : or built-in function \texttt{seq()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Print 'Hello!' 3 times}
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(}\StringTok{"Hello!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello!"
## [1] "Hello!"
## [1] "Hello!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{2}\NormalTok{, }\DataTypeTok{to =} \DecValTok{8}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)) \{}
    \KeywordTok{print}\NormalTok{(x}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 16
## [1] 36
## [1] 64
\end{verbatim}

\hypertarget{break}{%
\section{Break}\label{break}}

The \texttt{break} statement is used to exit the loop immediately. It simply jumps out of the loop altogether, and the program continues after the loop.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{5}

\CommentTok{# If statement starts as TRUE, the loop will never run}
\ControlFlowTok{while}\NormalTok{ (x }\OperatorTok{!=}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{1}

    \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{) \{}
        \KeywordTok{print}\NormalTok{(}\StringTok{"Entered IF statement, stop loop"}\NormalTok{)}
        \ControlFlowTok{break}
\NormalTok{    \}}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
## [1] 4
## [1] 3
## [1] "Entered IF statement, stop loop"
\end{verbatim}

\textbf{If not given an adequate stopping criteria or break statement the loop will continue forever.} For example, if we started the above examples at \texttt{x\ =\ -2}. The \texttt{break} statement is particularly important for the \texttt{while} loop.

The \texttt{break} statement can also be used in a \texttt{for} loop. It simply jumps out of the loop altogether, and the program continues after the loop.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{colors <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"green"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"yellow"}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ colors) \{}
    \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ "blue"}\NormalTok{) \{}
        \ControlFlowTok{break}
\NormalTok{    \}}
    \KeywordTok{print}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "red"
## [1] "green"
\end{verbatim}

The \texttt{for} loops do not have the same risk of ``running forever'', like \texttt{while} loops have.

\hypertarget{next}{%
\section{Next}\label{next}}

We can also use the \texttt{next} command in both \texttt{for} loops and \texttt{while} loops in order to skip executing a command.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) \{}

\NormalTok{    i <-}\StringTok{ }\NormalTok{i}\OperatorTok{^}\DecValTok{2}

    \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{) \{}
        \ControlFlowTok{next}
\NormalTok{    \}}

    \KeywordTok{print}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
## [1] 16
## [1] 25
## [1] 36
## [1] 49
## [1] 64
## [1] 81
## [1] 100
\end{verbatim}

The code inside the loop will run until it reaches the \texttt{next} statement. Once

\hypertarget{nested-loops}{%
\section{Nested Loops}\label{nested-loops}}

We can also create loops within loops. We refer to creating loops within other loops as a nested loop.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{) \{}
\NormalTok{        statement =}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\StringTok{"i="}\NormalTok{, i, }\StringTok{", j="}\NormalTok{, j)}
        \KeywordTok{print}\NormalTok{(statement)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "i= 1 , j= 1"
## [1] "i= 1 , j= 2"
## [1] "i= 1 , j= 3"
## [1] "i= 2 , j= 1"
## [1] "i= 2 , j= 2"
## [1] "i= 2 , j= 3"
## [1] "i= 3 , j= 1"
## [1] "i= 3 , j= 2"
## [1] "i= 3 , j= 3"
## [1] "i= 4 , j= 1"
## [1] "i= 4 , j= 2"
## [1] "i= 4 , j= 3"
## [1] "i= 5 , j= 1"
## [1] "i= 5 , j= 2"
## [1] "i= 5 , j= 3"
## [1] "i= 6 , j= 1"
## [1] "i= 6 , j= 2"
## [1] "i= 6 , j= 3"
## [1] "i= 7 , j= 1"
## [1] "i= 7 , j= 2"
## [1] "i= 7 , j= 3"
## [1] "i= 8 , j= 1"
## [1] "i= 8 , j= 2"
## [1] "i= 8 , j= 3"
## [1] "i= 9 , j= 1"
## [1] "i= 9 , j= 2"
## [1] "i= 9 , j= 3"
## [1] "i= 10 , j= 1"
## [1] "i= 10 , j= 2"
## [1] "i= 10 , j= 3"
\end{verbatim}

Here is an example of a nested loop which changes the elements of matrix to be the product of the row and column location.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(my_matrix)) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(my_matrix)) \{}
\NormalTok{        my_matrix[i, j] =}\StringTok{ }\NormalTok{i }\OperatorTok{*}\StringTok{ }\NormalTok{j}
\NormalTok{    \}}
\NormalTok{\}}

\NormalTok{my_matrix}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    2    4    6    8   10
## [3,]    3    6    9   12   15
## [4,]    4    8   12   16   20
## [5,]    5   10   15   20   25
\end{verbatim}

\hypertarget{examples-1}{%
\section{Examples}\label{examples-1}}

A few more examples.

\hypertarget{example-1}{%
\subsection{Example 1}\label{example-1}}

Below we create a function that has only one argument, \texttt{vec}, an arbitrary numeric vector. This function create a new vector containing all elements in \texttt{vec} whole numbers, and returns this new vector. If there are no whole numbers in \texttt{vec}, then it returns \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a subset of x which only contains whole numbers}
\CommentTok{# ARGUMENTS: vec, a numeric vector RETURNS: whole_vec, a}
\CommentTok{# vector containing all whole numbers will equal NA if}
\CommentTok{# there are no whole numbers}
\NormalTok{whole_num <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(vec) \{}

    \CommentTok{# Initialize whole_vec}
\NormalTok{    whole_vec <-}\StringTok{ }\OtherTok{NULL}

    \CommentTok{# For loop, go through each element in vec}
    \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ vec) \{}
        \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{==}\StringTok{ }\KeywordTok{round}\NormalTok{(i)) \{}
\NormalTok{            whole_vec <-}\StringTok{ }\KeywordTok{c}\NormalTok{(whole_vec, i)}
\NormalTok{        \}}
\NormalTok{    \}}

    \CommentTok{# Check to make sure there was at least one whole}
    \CommentTok{# number}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(whole_vec) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        whole_vec =}\StringTok{ }\OtherTok{NA}
\NormalTok{    \}}

    \KeywordTok{return}\NormalTok{(whole_vec)}
\NormalTok{\}}


\CommentTok{# Test case}
\NormalTok{tester <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FloatTok{5.5}\NormalTok{, }\FloatTok{10.8}\NormalTok{, pi, }\DecValTok{62}\NormalTok{)}
\KeywordTok{whole_num}\NormalTok{(tester)  }\CommentTok{# Should return 1, 3, 62}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  3 62
\end{verbatim}

\hypertarget{example-2}{%
\subsection{Example 2}\label{example-2}}

Below we create a function that has only one argument, \texttt{bound}, a numeric object of length one. This function returns the minimum number of subsequent whole numbers (starting from 1) that must be added together in order to reach (or surpass) \texttt{bound}. For example, suppose \texttt{bound=16}. Then \texttt{1+2+3+4+5\ =\ 15}, and \texttt{1+2+3+4+5+6\ =\ 21}. Thus, the function would return \texttt{6}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get_num <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{bound =} \DecValTok{16}\NormalTok{) \{}

    \CommentTok{# Initialize values}
\NormalTok{    total <-}\StringTok{ }\DecValTok{0}
\NormalTok{    i <-}\StringTok{ }\DecValTok{0}

    \CommentTok{# Use while loop to reach bound}
    \ControlFlowTok{while}\NormalTok{ (total }\OperatorTok{<=}\StringTok{ }\NormalTok{bound) \{}
\NormalTok{        i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{        total <-}\StringTok{ }\NormalTok{total }\OperatorTok{+}\StringTok{ }\NormalTok{i}
\NormalTok{    \}}
    \KeywordTok{return}\NormalTok{(i)}
\NormalTok{\}}

\KeywordTok{get_num}\NormalTok{(}\DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\hypertarget{additional-resources-5}{%
\section{Additional Resources}\label{additional-resources-5}}

\begin{itemize}
\tightlist
\item
  \href{https://bookdown.org/rdpeng/rprogdatascience/functions.html\#the-...-argument}{Chapter 13 of ``R for Programming in Data Science''}
\item
  Videos:

  \begin{itemize}
  \tightlist
  \item
    \href{https://ucr.yuja.com/V/Video?v=2369000\&node=8488272\&a=151697133\&autoplay=1}{Control Flow 6 \textbar{} while loops}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368999\&node=8488271\&a=621919520\&autoplay=1}{Control Flow 7 \textbar{} while loops Bisection Method}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368998\&node=8488270\&a=1160986069\&autoplay=1}{Control Flow 8 \textbar{} infinite while loops}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368997\&node=8488269\&a=148930850\&autoplay=1}{Control Flow 9 \textbar{} for loop Intro}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368996\&node=8488268\&a=160173707\&autoplay=1}{Control Flow 10 \textbar{} break and next}
  \item
    \href{https://ucr.yuja.com/V/Video?v=2368995\&node=8488267\&a=316843892\&autoplay=1}{Control Flow 11 \textbar{} nested for loops}
  \item
    \href{https://www.youtube.com/watch?v=HXNhEYqFo0o}{Programming Loops vs.~Recursion - Computerphile}
  \end{itemize}
\end{itemize}

\hypertarget{simulation}{%
\chapter{Simulation}\label{simulation}}

\hypertarget{what-are-simulation-studies}{%
\section{What Are Simulation Studies}\label{what-are-simulation-studies}}

Simulation studies are used in statistics to verify theoretical results, and to do ``what-if'' experiments. The are commonly used in a variety of applications and fields. Often times we have a particular theory or an idea about how things work. In order to verify that our theory is correct we can simulate a data set with known properties, and then check if the data set matches our theory. For example, suppose you want to calculate a 95\% confidence interval for the heights of all college students. Our theory on confidence intervals says that we expect that a 95\% confidence interval will capture the true mean about 95\% of the time. If we simply go out and take a sample of data from ``real-life'' and then calculate the a confidence interval we have no idea if that confidence interval captures the truth because the true average height of all college students is unknown! It is not feasible to sample every college students, so we will never know if the true mean actually falls within our interval. Furthermore, in this example we only calculated one confidence interval. If we did know the true mean then our results would simply indicate that the confidence interval captured the mean or not, but nothing about the \emph{rate} that confidence intervals capture the mean, which should be 95\%. What we can do instead is simulate this process. We can randomly generate data that has a true mean of \(\mu\) using a computer. Then we can estimate a 95\% confidence interval using the appropriate methods and see if this confidence interval contains \(\mu\). We then can repeat this process as many times as we would like because we are using a computer, which makes the process much simpler. If our theory about confidence intervals is correct we would expect that 95\% of our confidence intervals captured the true mean (\(\mu\)), and the rest did not.

Simulations are very important, and can range greatly in complexity. We will focus on simple techniques in this section. For a more complete discussion on simulation studies in statistics, and best practices see this freely available online at \url{https://onlinelibrary.wiley.com/doi/10.1002/sim.8086}.

\hypertarget{review-random-variables}{%
\section{Review Random Variables}\label{review-random-variables}}

Before discussing how to simulate data with specific properties we review the concept of a random variable. This discussion is adapted primarily from Chapter 3 and 4 of \citet{OpenIntro}. A \textbf{random variable} is a random process or variable with a numeric outcome. Random variables in general have a typical value which is called the \textbf{expected value}. However, in practice random variables also have variability, that is we do not expect to obtain the expected value for every random variable. Instead we expect to observe a range of values according to some sort of pattern, which is usually centered around the expected value.

For example, in Yellowstone National Park, Wyoming there is a famous geyser called Old Faithful. A geyser is a natural hot spring that periodically erupts water. The amount of time (in minutes) the eruption lasts varies each time, but not by a dramatic amount. The eruption time in minutes is the random variable, and the expected value is the average eruption length, and we can measure the variability using a measure of dispersion, like the variance. Below is a histogram of a random sample of eruptions times of 272 different eruptions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(faithful}\OperatorTok{$}\NormalTok{eruptions, }\DataTypeTok{main =} \StringTok{"Eruption Times of Old Faithful"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Time (in minutes)"}\NormalTok{, }\DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-215-1.pdf}

As mentioned previously, random variables generate observations according to some sort of pattern. These patterns are referred to as \textbf{densities}, and can be analyzed visually, and analytically (i.e.~through formulas). One of the most common ways to look at how often we would expect certain values for data that we find from the ``real-world'' is to use a histogram. Histogram order observations into mutually exclusive bins, where the height of each bin indicates how common a particular range of values is. For example, in the histogram above each bin is a 30 second (0.5 minute) range, and we can see the frequency of observations within the data set that are in this range on the y-axis. When thinking about random variables though, it is often more helpful to look at the proportion of observed values within a bin, instead of the frequency. We can modify our histogram to accomplish this.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(faithful}\OperatorTok{$}\NormalTok{eruptions, }\DataTypeTok{main =} \StringTok{"Eruption Times of Old Faithful"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Time (in minutes)"}\NormalTok{, }\DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.5}\NormalTok{),}
    \DataTypeTok{freq =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-216-1.pdf}

Notice that the y-axis now says ``Density''. This is the relative probability that an observed data point will be a particular value. In ``real-world'' data, we can only estimate the density. We will never know the truth. Hence, we will never know the true expected value, or the true variance. This is why we have statistics!! We have statistics in order to make educated guesses about these values and properties from which the data arises from.

Analyzing the density or pattern of a random variable visually with histograms is intuitive, but limiting. Using a formula as a representation for a density is much more versatile and useful. For these functions we have \textbf{parameters} which are values that let us further customize the function representation of a density to the specific random variable that we have. Let \(X\) be a random variable, and \(x\) be some observed value. In practice, if \(X\) is a random variable that can only take on values that are discrete (usually integers) then we say the probability of observing some a particular value, say \(x\), is denoted \(p(x)\). There are extremely well known discrete densities that random variables tend to follow and that are available in R. A few of them are listed below.

\begin{itemize}
\tightlist
\item
  \textbf{Binomial}:
\end{itemize}

\[p(x) = \binom{n}{x} p^x (1-p)^{n-x} \hspace{1cm} x = 0, ..., n\]

\begin{itemize}
\item
  \textbf{Poison}:
  \[p(x) = λ^x exp(-λ)/x! \hspace{1cm} x = 0, ..., n\]
\item
  \textbf{Negative Binomial:}
\end{itemize}

\[Γ(x+n)/(Γ(n) x!) p^n (1-p)^x   \hspace{1cm} x = 0, ..., \]

If \(X\) is a random variable that can be any value within a range of numbers then we denote the density function of this random variable by \(f(x)\). As with discrete random variables, there are extremely well known continuous densities that random variables tend to follow and that are available in R. A few of them are listed below.

\begin{itemize}
\tightlist
\item
  \textbf{Uniform:}
\end{itemize}

\[f(x) = 1/(max-min)\]

\begin{itemize}
\tightlist
\item
  \textbf{Log-Normal:}
\end{itemize}

\[f(x) = 1/(√(2 π) σ x) e^{-((log{(x)} - μ)^2 / (2 σ^2))} \hspace{1cm} 0 <x < \infty\]

\begin{itemize}
\tightlist
\item
  \textbf{Exponential:}
\end{itemize}

\[f(x) = λ {e}^{- λ x} \hspace{1cm} 0 <x < \infty\]

\begin{itemize}
\item
  \textbf{Normal}:
  \[f(x) = 1/(√(2 π) σ) e^{-((x - μ)^2/(2 σ^2))} \hspace{1cm} -\infty <x < \infty\]
\item
  \textbf{t-Distribution}
\end{itemize}

\[f(x) = Γ((n+1)/2) / (√(n π) Γ(n/2)) (1 + x^2/n)^-((n+1)/2)\hspace{1cm} -\infty <x < \infty\]

To see a complete list of well known distribution functions (or densities) that R already has see the help file \texttt{?Distributions}.

\hypertarget{generating-random-variables}{%
\section{Generating Random Variables}\label{generating-random-variables}}

Each distribution available in base R is listed in \texttt{?Distributions}. Each of the distributions has a link to their corresponding help file which lists four main functions: \texttt{dxxx()}, \texttt{pxxx()}, \texttt{qxxx()} and \texttt{rxxx()}. These are the density function, cumulative distribution function, quantile function, and a random number generator for the particular random variable of interest. The letters \texttt{xxx} are replaced by an code for the particular random variable. The density function (\texttt{dxxx()}) generates the relative probability of observing a particular value. The cumulative distribution function (\texttt{pxxx()}) generates the probability of observing a particular value, and anything smaller than this value. The quantile function (\texttt{qxxx()}) generates what value corresponds to a given percentile. Lastly, the random number generator (\texttt{rxxx()}) will generate a random variable according to the given distribuiton/density. We will focus only on \texttt{dxxx()} and \texttt{rxxx()}.

For example, go to \texttt{?Distributions} and click on \texttt{dnorm} which corresponds to the normal distribution (in the bottom third of the list). Here you will see the functions \texttt{dnorm()}, \texttt{pnorm()}, \texttt{qnorm()}, and \texttt{rnorm()}. To generate a normal random variable with mean 0 and standard deviation 1 we can use the following command.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Generate a single normal random variable with mean 0 and}
\CommentTok{# standard deviation 1}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.9734186
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Generate 20 normal random variables with mean 0 and}
\CommentTok{# standard deviation 1}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] -0.044839783  1.100497403  0.643893414  1.158084038 -0.104914360
##  [6] -1.392449727  1.018245804  0.826401081  1.289595050 -0.643231482
## [11] -0.001173311 -1.948468606  0.680949495  0.274233523 -1.905682922
## [16] -1.207395634  0.379645715 -0.832700980 -1.480467865  1.045205002
\end{verbatim}

However, as we saw in the previous section, these common distribution functions have parameters which let us further customize the behavior of the random variable. We can change the parameters of any of the distributions in R using the function arguments.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Normal random variable with mean 10, and standard}
\CommentTok{# deviation 0.5}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{10}\NormalTok{, }\DataTypeTok{sd =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10.60169
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Normal random variable with mean 10, and standard}
\CommentTok{# deviation 0.5}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{10}\NormalTok{, }\DataTypeTok{sd =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 10.571749  9.600775 10.356771 10.007255 10.532656  9.918810  9.633491
##  [8] 10.141749  9.903283 10.774333 10.138772  9.615449 10.785818 10.650341
## [15] 10.024944  9.791361 10.094124 10.505912 10.409901 10.263248
\end{verbatim}

To find the relative probability of observing a particular value for a normal distribution we use \texttt{dnorm()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Relative probability of observing the value 0.25 for a}
\CommentTok{# normal random variable with mean 0 and standard devation}
\CommentTok{# 1}
\KeywordTok{dnorm}\NormalTok{(}\FloatTok{0.25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3866681
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Relative probability of observing the value 0.25, -0.5, 2}
\CommentTok{# for a normal random variable with mean 0 and standard}
\CommentTok{# devation 1}
\KeywordTok{dnorm}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\FloatTok{0.25}\NormalTok{, }\FloatTok{-0.5}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.38666812 0.35206533 0.05399097
\end{verbatim}

\hypertarget{setting-a-seed}{%
\section{Setting a Seed}\label{setting-a-seed}}

Often times when running a simulation we will want to use the same numbers over and over again. The function \texttt{rxxx()} generates values randomly though, which means each time we call this function we will get new and different values. In order to make sure our values are consistent each time we run R, or across computers we can set the seed. The seed determines the way the computer generates our random numbers. Normally the seed is random, so each time \texttt{rxxx()} is called we get a new random sequence. Using the \texttt{set.seed()} function will make sure that the sequence stays the same each time we run \texttt{rxxx()}.

See the example below were generate a sequence of 10 uniform random variables that are between -5 and 5. If you copy this code directly into your computer you will get the same sequence. However, if you do not set the seed you will get a different sequence.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DataTypeTok{min =} \DecValTok{-5}\NormalTok{, }\DataTypeTok{max =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] -2.3449134 -1.2787610  0.7285336  4.0820779 -2.9831807  3.9838968
##  [7]  4.4467527  1.6079779  1.2911404 -4.3821373
\end{verbatim}

\hypertarget{sample}{%
\section{sample()}\label{sample}}

The \texttt{sample()} function is a powerful tool that can let you create your own unique random sequence. You can sample values with replacement, or without replacement. You can also assign certain probabilities to certain events. This is a particularly helpful function for rearranging rows, and for generating a sequence of categorical variables. For example, we can simulate a coin flip.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Heads"}\NormalTok{, }\StringTok{"Tails"}\NormalTok{), }\DataTypeTok{size =} \DecValTok{1}\NormalTok{, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Tails"
\end{verbatim}

Below is the code for simulating 10 coin flips.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Heads"}\NormalTok{, }\StringTok{"Tails"}\NormalTok{), }\DataTypeTok{size =} \DecValTok{10}\NormalTok{, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Tails" "Heads" "Tails" "Heads" "Tails" "Heads" "Heads" "Tails" "Heads"
## [10] "Heads"
\end{verbatim}

We can set the seed like we did before in order to insure we keep getting the same sample each time we run this code.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Heads"}\NormalTok{, }\StringTok{"Tails"}\NormalTok{), }\DataTypeTok{size =} \DecValTok{10}\NormalTok{, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Tails" "Tails" "Heads" "Heads" "Tails" "Heads" "Heads" "Heads" "Heads"
## [10] "Tails"
\end{verbatim}

\hypertarget{replicate}{%
\section{replicate()}\label{replicate}}

The \texttt{replicate()} function repeats a function call \texttt{n} times in a very efficient way. Suppose we wish to find the probability we get exactly 3 heads if we flip a coin 10 times. We can replicate flipping a coin 10 times, and count how many of these times we see exactly 3 heads.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coin_flip_heads3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    coin_flip <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Heads"}\NormalTok{, }\StringTok{"Tails"}\NormalTok{), }\DataTypeTok{size =} \DecValTok{10}\NormalTok{, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{,}
        \FloatTok{0.5}\NormalTok{), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{    num_heads <-}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{which}\NormalTok{(coin_flip }\OperatorTok{==}\StringTok{ "Heads"}\NormalTok{))}

    \ControlFlowTok{if}\NormalTok{ (num_heads }\OperatorTok{==}\StringTok{ }\DecValTok{3}\NormalTok{) \{}
\NormalTok{        heads3 =}\StringTok{ }\OtherTok{TRUE}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        heads3 =}\StringTok{ }\OtherTok{FALSE}
\NormalTok{    \}}
    \KeywordTok{return}\NormalTok{(heads3)}
\NormalTok{\}}



\CommentTok{# Generates flipping a coin 3 times Returns TRUE if exactly}
\CommentTok{# 3 flips resulted in heads Returns FALSE if otherwise}
\KeywordTok{coin_flip_heads3}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Replicate the experiment 10,000 times}
\NormalTok{see_heads3 <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\KeywordTok{coin_flip_heads3}\NormalTok{())}

\CommentTok{# How many of these experiments results in 3 heads???}
\CommentTok{# Probability of seeing exactly 3 heads is approximately}
\CommentTok{# 12%}
\KeywordTok{table}\NormalTok{(see_heads3)}\OperatorTok{/}\DecValTok{10000}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## see_heads3
##  FALSE   TRUE 
## 0.8861 0.1139
\end{verbatim}

\hypertarget{adding-curves-to-graphs}{%
\section{Adding curves to graphs}\label{adding-curves-to-graphs}}

Often times when generating data or using a real-world data set we might want to see how well a well known distribution fits a particular data set. We can do so by adding the proposed density function on to a histogram which contains the data set of interest. For example, suppose we wish to see if a normal distribution with mean of 3.5 and standard deviation of 1.14 fits the old faithful data set for eruption times. We can add this density function on top and see if it approximately fits the data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(faithful}\OperatorTok{$}\NormalTok{eruptions, }\DataTypeTok{main =} \StringTok{"Eruption Times of Old Faithful"}\NormalTok{,}
    \DataTypeTok{xlab =} \StringTok{"Time (in minutes)"}\NormalTok{, }\DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.5}\NormalTok{),}
    \DataTypeTok{freq =} \OtherTok{FALSE}\NormalTok{)}

\KeywordTok{curve}\NormalTok{(}\KeywordTok{dnorm}\NormalTok{(x, }\FloatTok{3.5}\NormalTok{, }\FloatTok{1.14}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-225-1.pdf}

Now lets generate 272 normal random variables with mean 3.5 and standard deviation of 1.14 and see how well are generated data matches the density function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gen_data <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{272}\NormalTok{, }\DataTypeTok{mean =} \FloatTok{3.5}\NormalTok{, }\DataTypeTok{sd =} \FloatTok{1.14}\NormalTok{)}

\KeywordTok{hist}\NormalTok{(gen_data, }\DataTypeTok{main =} \StringTok{"Simulated Data"}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\OperatorTok{-}\FloatTok{0.5}\NormalTok{,}
    \DecValTok{7}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.5}\NormalTok{), }\DataTypeTok{freq =} \OtherTok{FALSE}\NormalTok{)}

\KeywordTok{curve}\NormalTok{(}\KeywordTok{dnorm}\NormalTok{(x, }\FloatTok{3.5}\NormalTok{, }\FloatTok{1.14}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-226-1.pdf}

We do not see a perfect fit, but this is what happens with random samples. The fit for the simulated data is what we expect approximately if we had a sample with this distribution. It should be approximately the same as the curve, which we see for the simulated data. Our old faithful data is significantly less fitted the simulated data. Thus it appears that the old faithful eruption times is probably not normally distributed with mean 3.5 and standard deviation 1.14. How similar is ``similar enough'' is not a hard and fast rule, and it is ultimately up to the researcher. The simulated data set gives us a general idea of what is ``similar enough''.

Note that the \texttt{curve()} function does not need to be added to graph but can stand alone.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{curve}\NormalTok{(}\KeywordTok{dnorm}\NormalTok{(x, }\FloatTok{3.5}\NormalTok{, }\FloatTok{1.14}\NormalTok{), }\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DataTypeTok{add =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-227-1.pdf}

In addition, we can make our own functions to plot using \texttt{curve()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_fun <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    y =}\StringTok{ }\NormalTok{x}\OperatorTok{^}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{3}
    \KeywordTok{return}\NormalTok{(y)}
\NormalTok{\}}

\KeywordTok{curve}\NormalTok{(}\KeywordTok{my_fun}\NormalTok{(x), }\DecValTok{-10}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-228-1.pdf}

\hypertarget{example-central-limit-theorem-clt}{%
\section{Example: Central Limit Theorem (CLT)}\label{example-central-limit-theorem-clt}}

\hypertarget{recall-clt}{%
\subsection{Recall CLT}\label{recall-clt}}

Let \(X_1, ..., X_n\) be independent and identically distributed random variables with mean and variance, \(\mu\) and \(\sigma^2\). If the sample size is sufficiently large (\(n \geq 30\)), the sample mean \(\bar{x}\) will tend to follow a normal distribution with mean \(\mu\) and standard deviation \(\frac{\sigma}{\sqrt{n}}\).

In other words, for any set of data \(X_1, ..., X_n\) that is independent and comes from the same distribution, and that distribution has a finite mean and variance, \(\mu\) and \(\sigma^2\). Then

\[\bar{x} \sim N \left ( \mu, \frac{\sigma}{\sqrt{n}} \right ) \]

The distribution above is a \emph{sampling distribution}. It is the distribution of a \emph{sample mean}. That is, if we take \(k\) samples, and for each sample we calculated the mean, the central limit theorem tells us about the distribution of these means (\(\bar{x}_1, \dots, \bar{x}_k\)).

\hypertarget{assumption-violations-of-clt}{%
\subsection{Assumption Violations of CLT}\label{assumption-violations-of-clt}}

The central limit theorem has a few key assumptions. Some of these assumptions are fairly easy to meet, and others are more susceptible to being violated. For example, typically it is reasonable to assume that mean and variance are finite. Other assumptions are easier to violate, and the consequences of violating these assumptions vary greatly. Sometimes we may have data that comes from a mix of multiple distributions, this violate the assumption that data is identically distributed. Another assumption violation could be independence. For example, in time series data we typically observe a random variable over a sequence of time and measure it repeatedly. This would violate the independence assumption because earlier observations are typically related to future observations. Another assumption that is often violated is the minimum sample size. The central limit theorem says we need at least 30 observations, or else we should use the t-distribution instead. Historically this is usually not a very big problem. The requirement that our sample size is at least 30 is a ``rule of thumb'' and not based on rigorous statistical theory.

Below are a summary of these assumptions restated:

\begin{itemize}
\item
  All our observations are independent, and have the same distribution (come from same population)
\item
  Sample size is greater than 30 (\(n\geq 30\))
\item
  The mean and the variance of the distribution the data comes from are finite (\(|\mu|< \infty, |\sigma^2|< \infty\))
\end{itemize}

Once we have verified these assumptions, we still need to determine what the mean (\(\mu\)) and variance (\(\sigma^2\)) are. If we know that our distribution is one of the really common ones above, then this task becomes much eaiser.

\hypertarget{the-data}{%
\subsection{The Data}\label{the-data}}

We will see how well the CLT theorem applies to a data set that has a uniform distribution. That is, say we have a sample of 50 observations which we believe are all uniformly distributed between -5 and 5. We want to determine if the mean of a sample of this type would be normally distributed according to the CLT. To do so, we simulate a sample of this type 10,000 times and assess if it matches the CLT results.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Simulate a sample of 50 observations that are uniformly}
\CommentTok{# distributed}
\NormalTok{gen_unif_mean =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(the_min, the_max) \{}
\NormalTok{    gen_data =}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{50}\NormalTok{, the_min, the_max)}
\NormalTok{    the_mean =}\StringTok{ }\KeywordTok{mean}\NormalTok{(gen_data)}
\NormalTok{    the_parameters =}\StringTok{ }\KeywordTok{c}\NormalTok{(the_min, the_max)}
\NormalTok{    results =}\StringTok{ }\KeywordTok{list}\NormalTok{(the_mean, the_parameters)}
    \KeywordTok{names}\NormalTok{(results) =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"parameters"}\NormalTok{)}
    \KeywordTok{return}\NormalTok{(results)}
\NormalTok{\}}

\CommentTok{# Simulate 10000 samples, each of size 50, where the}
\CommentTok{# minumum value is -5 And the maximum value is 5}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\NormalTok{sim_means <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\KeywordTok{gen_unif_mean}\NormalTok{(}\DataTypeTok{the_min =} \DecValTok{-5}\NormalTok{, }\DataTypeTok{the_max =} \DecValTok{5}\NormalTok{)}\OperatorTok{$}\NormalTok{mean)}


\CommentTok{# histogram of results}
\KeywordTok{hist}\NormalTok{(sim_means, }\DataTypeTok{freq =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-229-1.pdf}

To add a curve to the graph we need to know the mean and the standard deviation of the data we generated. For a uniform distribution with a minimum of -5 and a maximum of 5, the mean is 0 and the standard deviation is \(10/\sqrt{12} \approx 2.89\). Thus according to CLT, we expect our histogram above to correspond to a normal density with mean 0 and standard deviation \(2.89/\sqrt{50} \approx 0.41\).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# histogram of results}
\KeywordTok{hist}\NormalTok{(sim_means, }\DataTypeTok{freq =} \OtherTok{FALSE}\NormalTok{)}

\CommentTok{# Add normal curve according to CLT}
\KeywordTok{curve}\NormalTok{(}\KeywordTok{dnorm}\NormalTok{(x, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \FloatTok{0.41}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-230-1.pdf}

\hypertarget{tidyverse}{%
\chapter{Tidyverse}\label{tidyverse}}

For this document you will need to install and load the family of packages \texttt{tidyverse} functions. To install the package refer to Section \ref{packages}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

The tidyverse is a collection of packages that share a unique underlying philosophy, frame work, and syntax. There are approximately 20 tidyverse packages, but the core ones are \texttt{ggplot2}, \texttt{dplyr}, \texttt{tidyr}, \texttt{readr}, \texttt{purr}, \texttt{tibble}, \texttt{stringr}, and \texttt{forcats}. You can install these packages individually or all at once using by simply using the command \texttt{install.packages("tidyverse")}.

In general, the tidyverse syntax is structured in a way where we think about ``actions'' instead of ``objects''. In other words, we think about coding in terms of verbs instead of nouns.

The overall tidyverse structure and syntax is unique. Some believe that this method of coding is more user friendly to beginners. Beginners can do more complex things faster. The major criticisms of tidyverse is that the help files, structure, and syntax is too much of a deviation from base R. It is also sometimes not flexible enough for unique high level commands. Base R (or traditional R) is very similar to a variety of the other languages like Python or C. Techniques learned used based R can be much more versatile depending on your needs.

\hypertarget{piping-operator}{%
\section{Piping Operator}\label{piping-operator}}

The tidyverse syntax structure and form can sometimes be used like traditional base R functions, but were designed to use a ``piping'' operator. This operator is not in base R, so you will either need to define it yourself, or load it as a package. The piping operator feeds what ever is on the left of the operator as the first argument for the function on the right side of the operator. For example, here we feed the vector \texttt{vec} into the first argument of the base R function \texttt{mean()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{vec }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.5
\end{verbatim}

This operator was designed to be used when we have a sequence of multiple operations. With this operator we ``pipe'' the output of one function into the next using `\%\textgreater\%'. The idea is to focus on actions and not objects.

\hypertarget{tibbles-vs-data-frames}{%
\section{Tibbles vs Data Frames}\label{tibbles-vs-data-frames}}

We also have a new type of object with tidyverse called a \textbf{tibble}. A tibble is a new type of 2D object, and is very similar to a data frame. We have actually already used tibbles and tidyverse a little bit when we were loading data. In section \ref{LoadData} we discussed how to load a csv file using the \texttt{read\_csv()} which required the \texttt{readr} package, a package in the tidyverse suite. When we load a csv file using \texttt{read\_csv()} we are actually loading in a tibble object, not a data frame.

Tibbles and data frames are very similar. There is one main difference. Consider the \texttt{diamonds} data set below. This is a data set that is part of the \texttt{tidyverse} packages. When the packages are loaded we can call this data set at any time, just as we do for a built in base R data set. The \texttt{diamonds} data set is a tibble, and not a data frame. When we print it, or type its name to display it, only the first 10 rows will be displayed and all columns that fit on the screen or output space. The other thing that we notice is that the column type is displayed, \texttt{\textless{}type\textgreater{}}. Below each row we can see if the column has doubles \texttt{\textless{}dbl\textgreater{}}, ordered factors \texttt{\textless{}ord\textgreater{}}, integers \texttt{\textless{}int\textgreater{}}, characters \texttt{\textless{}chr\textgreater{}}, logical values \texttt{\textless{}logi\textgreater{}}, etc.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The tidyverse data set diamonds is a tibble}
\KeywordTok{class}\NormalTok{(diamonds)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dim}\NormalTok{(diamonds)  }\CommentTok{# 53940 rows, 10 columns }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 53940    10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Tibbles only show first ten rows, and however many}
\CommentTok{# columns fill up the screen}
\NormalTok{diamonds}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows
\end{verbatim}

In contrast if we type the name of the data set in a data frame format then all the rows, and all the columns will be displayed. If the data set does not fit in the print space the format will just be manipulated. We also do not have column types displayed below the column names for a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(diamonds)}
\NormalTok{diamonds_df[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    carat       cut color clarity depth table price    x    y    z
## 1   0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
## 2   0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
## 3   0.23      Good     E     VS1  56.9    65   327 4.05 4.07 2.31
## 4   0.29   Premium     I     VS2  62.4    58   334 4.20 4.23 2.63
## 5   0.31      Good     J     SI2  63.3    58   335 4.34 4.35 2.75
## 6   0.24 Very Good     J    VVS2  62.8    57   336 3.94 3.96 2.48
## 7   0.24 Very Good     I    VVS1  62.3    57   336 3.95 3.98 2.47
## 8   0.26 Very Good     H     SI1  61.9    55   337 4.07 4.11 2.53
## 9   0.22      Fair     E     VS2  65.1    61   337 3.87 3.78 2.49
## 10  0.23 Very Good     H     VS1  59.4    61   338 4.00 4.05 2.39
\end{verbatim}

\hypertarget{key-functions}{%
\section{Key Functions}\label{key-functions}}

There are a few key functions and operations that we will focus on in the tidyverse suite. Tidyverse is a gigantic collections of functions and objects, but these are a few of the main ones to help you get started.

Note, in general, for tidyverse help files arguments typically start with a ``.'', this in contrast to many of the base R help files where arguments are in all caps.

\begin{itemize}
\item
  \texttt{select()}: Select variables in a data frame.
\item
  \texttt{filter()}: Subset a data frame, retaining all rows that satisfy your conditions.
\item
  \texttt{arrange()}: Orders the rows of a data frame by the values of selected columns.
\item
  \texttt{rename()}: Changes the names of individual variables using \texttt{new\_name\ =\ old\_name} syntax
\item
  \texttt{mutate()}: Adds new variables and preserves existing ones.
\item
  \texttt{group\_by()}: Takes an existing tibble and converts it into a grouped tibble where operations can then be performed ``by group''.
\item
  \texttt{summarize()/summarise()}: Summarizes results for each group (rows), and summary statistics (columns).
\end{itemize}

\hypertarget{general-properties}{%
\subsection{General properties}\label{general-properties}}

In general, all the functions above have the following properties:

\begin{itemize}
\item
  The first argument is a data frame or a tibble.
\item
  The subsequent arguments are used to determine what to do with the data-frame/tibble in the first argument.
\item
  The returned value is a data frame or a tibble.
\item
  The inputted data-frames/tibbles should be well formatted to start off with. Each row should be an observation, and each column should be a variable.
\item
  When we refer to column names for the data frame or tibble in the first argument we do not need to use quotes around the column names.
\end{itemize}

\hypertarget{select}{%
\subsection{select()}\label{select}}

We use this function to isolate particular columns that we isolate.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(price, cut)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 2
##    price cut      
##    <int> <ord>    
##  1   326 Ideal    
##  2   326 Premium  
##  3   327 Good     
##  4   334 Premium  
##  5   335 Good     
##  6   336 Very Good
##  7   336 Very Good
##  8   337 Very Good
##  9   337 Fair     
## 10   338 Very Good
## # ... with 53,930 more rows
\end{verbatim}

To store the output we need to use an assignment operator.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{PriceCut <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(price, cut)}
\NormalTok{PriceCut}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 2
##    price cut      
##    <int> <ord>    
##  1   326 Ideal    
##  2   326 Premium  
##  3   327 Good     
##  4   334 Premium  
##  5   335 Good     
##  6   336 Very Good
##  7   336 Very Good
##  8   337 Very Good
##  9   337 Fair     
## 10   338 Very Good
## # ... with 53,930 more rows
\end{verbatim}

You can also use the operator ``:'', and negative signs with the \texttt{select()} function. With the ``name1:name2'' operator we can select all columns between the column named ``name1'' and ``name2''. With negative signs we can omit all variables that are preceeded with a negative sign. These methods are typically not allowed in standard indexing when using names, as covered in \ref{VectorIndex}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Select all columns between cut and price.}
\NormalTok{PriceCut <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(cut}\OperatorTok{:}\NormalTok{price)}
\NormalTok{PriceCut}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 6
##    cut       color clarity depth table price
##    <ord>     <ord> <ord>   <dbl> <dbl> <int>
##  1 Ideal     E     SI2      61.5    55   326
##  2 Premium   E     SI1      59.8    61   326
##  3 Good      E     VS1      56.9    65   327
##  4 Premium   I     VS2      62.4    58   334
##  5 Good      J     SI2      63.3    58   335
##  6 Very Good J     VVS2     62.8    57   336
##  7 Very Good I     VVS1     62.3    57   336
##  8 Very Good H     SI1      61.9    55   337
##  9 Fair      E     VS2      65.1    61   337
## 10 Very Good H     VS1      59.4    61   338
## # ... with 53,930 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Select all but price and cut}
\NormalTok{NotPriceCut <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\NormalTok{price, }\OperatorTok{-}\NormalTok{cut)}
\NormalTok{NotPriceCut}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 8
##    carat color clarity depth table     x     y     z
##    <dbl> <ord> <ord>   <dbl> <dbl> <dbl> <dbl> <dbl>
##  1 0.23  E     SI2      61.5    55  3.95  3.98  2.43
##  2 0.21  E     SI1      59.8    61  3.89  3.84  2.31
##  3 0.23  E     VS1      56.9    65  4.05  4.07  2.31
##  4 0.290 I     VS2      62.4    58  4.2   4.23  2.63
##  5 0.31  J     SI2      63.3    58  4.34  4.35  2.75
##  6 0.24  J     VVS2     62.8    57  3.94  3.96  2.48
##  7 0.24  I     VVS1     62.3    57  3.95  3.98  2.47
##  8 0.26  H     SI1      61.9    55  4.07  4.11  2.53
##  9 0.22  E     VS2      65.1    61  3.87  3.78  2.49
## 10 0.23  H     VS1      59.4    61  4     4.05  2.39
## # ... with 53,930 more rows
\end{verbatim}

\hypertarget{filter}{%
\subsection{filter()}\label{filter}}

The function \texttt{filter()} is like \texttt{select()} but we focus on the rows we wish to keep instead of the columns. The arguments inside the \texttt{filter()} function correspond to conditions we wish to keep. Again, when referring to columns inside of the tidyverse functions we do not need to put the column names in quotes.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# What is the mean value for the depth column?}
\KeywordTok{mean}\NormalTok{(diamonds}\OperatorTok{$}\NormalTok{depth)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 61.7494
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamondsFiltered <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(depth }\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(depth))}
\NormalTok{diamondsFiltered}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 28,909 x 10
##    carat cut       color clarity depth table price     x     y     z
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
##  1 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  2 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  3 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  4 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  5 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  6 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
##  7 0.3   Good      J     SI1      64      55   339  4.25  4.28  2.73
##  8 0.23  Ideal     J     VS1      62.8    56   340  3.93  3.9   2.46
##  9 0.31  Ideal     J     SI2      62.2    54   344  4.35  4.37  2.71
## 10 0.3   Ideal     I     SI2      62      54   348  4.31  4.34  2.68
## # ... with 28,899 more rows
\end{verbatim}

We can filter on multiple conditions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamondsFiltered <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(depth }\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(depth), cut }\OperatorTok{==}\StringTok{ "Good"}\NormalTok{, price }\OperatorTok{>}\StringTok{ }\DecValTok{350}\NormalTok{)}
\NormalTok{diamondsFiltered}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3,548 x 10
##    carat cut   color clarity depth table price     x     y     z
##    <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
##  1  0.3  Good  J     SI1      63.4    54   351  4.23  4.29  2.7 
##  2  0.3  Good  J     SI1      63.8    56   351  4.23  4.26  2.71
##  3  0.3  Good  I     SI2      63.3    56   351  4.26  4.3   2.71
##  4  0.23 Good  E     VS1      64.1    59   402  3.83  3.85  2.46
##  5  0.31 Good  H     SI1      64      54   402  4.29  4.31  2.75
##  6  0.26 Good  D     VS2      65.2    56   403  3.99  4.02  2.61
##  7  0.32 Good  H     SI2      63.1    56   403  4.34  4.37  2.75
##  8  0.32 Good  H     SI2      63.8    56   403  4.36  4.38  2.79
##  9  0.3  Good  I     SI1      63.2    55   405  4.25  4.29  2.7 
## 10  0.3  Good  H     SI1      63.7    57   554  4.28  4.26  2.72
## # ... with 3,538 more rows
\end{verbatim}

\hypertarget{arrange}{%
\subsection{arrange()}\label{arrange}}

The \texttt{arrange()} function is much like \texttt{sort()} or \texttt{order()} in base R.

\hypertarget{rename}{%
\subsection{rename()}\label{rename}}

The \texttt{rename()} is used to replace the \texttt{colnames()} function. Every argument in the \texttt{rename()} function should have the structure \texttt{NewName\ =\ OldName}. That is, we should have the new column name on the left and original column name on the right. For example lets say we want rename the column \texttt{cut} to \texttt{Cut}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{rename}\NormalTok{(}\DataTypeTok{Cut =}\NormalTok{ cut)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 10
##    carat Cut       color clarity depth table price     x     y     z
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows
\end{verbatim}

We can do this as many columns as we would like. Now lets try renaming the \texttt{cut} and the \texttt{color} columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{rename}\NormalTok{(}\DataTypeTok{Cut =}\NormalTok{ cut, }\DataTypeTok{Color =}\NormalTok{ color)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 10
##    carat Cut       Color clarity depth table price     x     y     z
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows
\end{verbatim}

Remember, to save your results, you still need to use the assignment operator and rename the object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds_new <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{rename}\NormalTok{(}\DataTypeTok{Cut =}\NormalTok{ cut, }\DataTypeTok{Color =}\NormalTok{ color)}
\end{Highlighting}
\end{Shaded}

\hypertarget{mutate}{%
\subsection{mutate()}\label{mutate}}

We use the \texttt{mutate()} function to add or change a variable. Like the preceeds functions before it, you still do not need quotes around the column names to refer to them. Suppose to change the \texttt{price} column to be in hundreds of dollars (instead of dollars).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{price =}\NormalTok{ price}\OperatorTok{/}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
##  1 0.23  Ideal     E     SI2      61.5    55  3.26  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61  3.26  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65  3.27  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58  3.34  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58  3.35  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57  3.36  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57  3.36  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55  3.37  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61  3.37  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61  3.38  4     4.05  2.39
## # ... with 53,930 more rows
\end{verbatim}

We can adjust multiple columns at once, and even add columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamondsNEW <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{price =}\NormalTok{ price}\OperatorTok{/}\DecValTok{100}\NormalTok{, }\DataTypeTok{depthNEW =} \DecValTok{10} \OperatorTok{*}\StringTok{ }\NormalTok{depth }\OperatorTok{+}\StringTok{ }\NormalTok{price)}
\NormalTok{diamondsNEW}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 11
##    carat cut       color clarity depth table price     x     y     z depthNEW
##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>
##  1 0.23  Ideal     E     SI2      61.5    55  3.26  3.95  3.98  2.43     618.
##  2 0.21  Premium   E     SI1      59.8    61  3.26  3.89  3.84  2.31     601.
##  3 0.23  Good      E     VS1      56.9    65  3.27  4.05  4.07  2.31     572.
##  4 0.290 Premium   I     VS2      62.4    58  3.34  4.2   4.23  2.63     627.
##  5 0.31  Good      J     SI2      63.3    58  3.35  4.34  4.35  2.75     636.
##  6 0.24  Very Good J     VVS2     62.8    57  3.36  3.94  3.96  2.48     631.
##  7 0.24  Very Good I     VVS1     62.3    57  3.36  3.95  3.98  2.47     626.
##  8 0.26  Very Good H     SI1      61.9    55  3.37  4.07  4.11  2.53     622.
##  9 0.22  Fair      E     VS2      65.1    61  3.37  3.87  3.78  2.49     654.
## 10 0.23  Very Good H     VS1      59.4    61  3.38  4     4.05  2.39     597.
## # ... with 53,930 more rows
\end{verbatim}

In addition, there is also the \texttt{transmute()} function which does the same thing as \texttt{mutate()} but \emph{drops all other variables}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamondsNEW <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{transmute}\NormalTok{(}\DataTypeTok{price =}\NormalTok{ price}\OperatorTok{/}\DecValTok{100}\NormalTok{, }\DataTypeTok{depthNEW =} \DecValTok{10} \OperatorTok{*}\StringTok{ }\NormalTok{depth }\OperatorTok{+}\StringTok{ }\NormalTok{price)}
\NormalTok{diamondsNEW}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 2
##    price depthNEW
##    <dbl>    <dbl>
##  1  3.26     618.
##  2  3.26     601.
##  3  3.27     572.
##  4  3.34     627.
##  5  3.35     636.
##  6  3.36     631.
##  7  3.36     626.
##  8  3.37     622.
##  9  3.37     654.
## 10  3.38     597.
## # ... with 53,930 more rows
\end{verbatim}

\hypertarget{group_by}{%
\subsection{group\_by()}\label{group_by}}

The \texttt{group\_by()} function is typically used with the \texttt{sumarize()/summarise()} function. We use \texttt{group\_by()} to group sets of observations all together. The arguments dictate the groups to create by specify columns, which are typically factor or character columns.

\hypertarget{summarizesummarise}{%
\subsection{summarize()/summarise()}\label{summarizesummarise}}

The functions \texttt{summarize()} and \texttt{summarise()} are the same. The arguments inside this function specify the summary statistics to create useing \texttt{NewColumnName\ =\ \textless{}statistic\textgreater{}}. We use this function with \texttt{group\_by()}, so that way we can create summary statistics for each group. When we go from one function to another we still use the piping operator, \texttt{\%\textgreater{}\%}.

Here is an example where we group by cut, and then calculate the mean price for each cut. This results in a new data frame with a new column called \texttt{PriceMean}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{PriceMean =} \KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 5 x 2
##   cut       PriceMean
##   <ord>         <dbl>
## 1 Fair          4359.
## 2 Good          3929.
## 3 Very Good     3982.
## 4 Premium       4584.
## 5 Ideal         3458.
\end{verbatim}

We can also do this by multiple groups and summary statistics.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut, color) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{PriceMean =} \KeywordTok{mean}\NormalTok{(price), }\DataTypeTok{PriceMedian =} \KeywordTok{median}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` regrouping output by 'cut' (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 35 x 4
## # Groups:   cut [5]
##    cut   color PriceMean PriceMedian
##    <ord> <ord>     <dbl>       <dbl>
##  1 Fair  D         4291.       3730 
##  2 Fair  E         3682.       2956 
##  3 Fair  F         3827.       3035 
##  4 Fair  G         4239.       3057 
##  5 Fair  H         5136.       3816 
##  6 Fair  I         4685.       3246 
##  7 Fair  J         4976.       3302 
##  8 Good  D         3405.       2728.
##  9 Good  E         3424.       2420 
## 10 Good  F         3496.       2647 
## # ... with 25 more rows
\end{verbatim}

We can do several summary statistics at once.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{PriceMean =} \KeywordTok{mean}\NormalTok{(price), }\DataTypeTok{PriceMedian =} \KeywordTok{median}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 5 x 3
##   cut       PriceMean PriceMedian
##   <ord>         <dbl>       <dbl>
## 1 Fair          4359.       3282 
## 2 Good          3929.       3050.
## 3 Very Good     3982.       2648 
## 4 Premium       4584.       3185 
## 5 Ideal         3458.       1810
\end{verbatim}

\hypertarget{examples-2}{%
\section{Examples}\label{examples-2}}

\hypertarget{example-1-1}{%
\subsection{Example 1}\label{example-1-1}}

Get a new column which is the product of \texttt{depth} and \texttt{carat}, call it \texttt{DxC}. Calculate the (arithmetic) mean of this new variable, and the (arithmetic) mean of \texttt{price} by each \texttt{cut}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{DxC =}\NormalTok{ depth }\OperatorTok{*}\StringTok{ }\NormalTok{carat) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{AvgDxC =} \KeywordTok{mean}\NormalTok{(DxC), }\DataTypeTok{AvgCut =} \KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 5 x 3
##   cut       AvgDxC AvgCut
##   <ord>      <dbl>  <dbl>
## 1 Fair        67.2  4359.
## 2 Good        52.9  3929.
## 3 Very Good   49.9  3982.
## 4 Premium     54.6  4584.
## 5 Ideal       43.4  3458.
\end{verbatim}

\hypertarget{example-2-1}{%
\subsection{Example 2}\label{example-2-1}}

Isolate the observations that have \texttt{cut} as ``Ideal''. Only keep the cut, carat, depth, and price columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(cut }\OperatorTok{==}\StringTok{ "Ideal"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(cut, carat, depth, price)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 21,551 x 4
##    cut   carat depth price
##    <ord> <dbl> <dbl> <int>
##  1 Ideal  0.23  61.5   326
##  2 Ideal  0.23  62.8   340
##  3 Ideal  0.31  62.2   344
##  4 Ideal  0.3   62     348
##  5 Ideal  0.33  61.8   403
##  6 Ideal  0.33  61.2   403
##  7 Ideal  0.33  61.1   403
##  8 Ideal  0.23  61.9   404
##  9 Ideal  0.32  60.9   404
## 10 Ideal  0.3   61     405
## # ... with 21,541 more rows
\end{verbatim}

\hypertarget{example-3}{%
\subsection{Example 3}\label{example-3}}

Consider only the observations where \texttt{price} is larger than the median \texttt{price}. Determine the (arithmetic) mean and min value for the \texttt{depth} variable by \texttt{color}. Sort the results in order from smallest to largest value for (arithmetic) mean \texttt{depth} for each group. Display only the first 15 rows of the resulting matrix.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(price }\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(price)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(color) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{mean_depth =} \KeywordTok{mean}\NormalTok{(depth), }\DataTypeTok{min_depth =} \KeywordTok{min}\NormalTok{(depth)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{arrange}\NormalTok{(mean_depth) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{head}\NormalTok{(}\DataTypeTok{n =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 7 x 3
##   color mean_depth min_depth
##   <ord>      <dbl>     <dbl>
## 1 D           61.7      55.5
## 2 E           61.7      53.1
## 3 F           61.8      55.4
## 4 G           61.8      43  
## 5 I           61.8      50.8
## 6 H           61.8      54.7
## 7 J           61.9      43
\end{verbatim}

\hypertarget{additional-resources-6}{%
\section*{Additional Resources}\label{additional-resources-6}}
\addcontentsline{toc}{section}{Additional Resources}

To learn more about Tidyverse, check out the official website, a book on helpful information, and the official cheat sheets.

\begin{itemize}
\item
  \url{https://www.tidyverse.org/}
\item
  \url{https://r4ds.had.co.nz/index.html}
\item
  Cheatsheets!
\item
  \url{https://cfss.uchicago.edu/notes/pipes/}
\end{itemize}

\hypertarget{ggplot2}{%
\chapter{ggplot2}\label{ggplot2}}

\hypertarget{tidyverse-and-ggplot2}{%
\section{Tidyverse and ggplot2}\label{tidyverse-and-ggplot2}}

For this document you will need to install and load the package \texttt{ggplot2} which is part of \texttt{tidyverse}. To install the package refer to Section \ref{packages}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

The tidyverse is a collection of packages that share a unique underlying philosophy, frame work, and syntax. There are approximately 20 tidyverse packages, but the core ones are \texttt{ggplot2}, \texttt{dplyr}, \texttt{tidyr}, \texttt{readr}, \texttt{purr}, \texttt{tibble}, \texttt{stringr}, and \texttt{forcats}. You can install these packages individually or all at once using by simply using the command \texttt{install.packages("tidyverse")}.

We will be focusing on the \texttt{ggplot2} package for now. The functions and topics that we that we will be covering can be found in \citet{wickham2009elegant}.

\hypertarget{intro-to-ggplot2}{%
\section{Intro to ggplot2}\label{intro-to-ggplot2}}

The package \texttt{ggplot2} is used to produce graphics using a different system then traditional ``Base R''. It has an underlying grammar or style that is different that is based on the ``grammar of graphics''.

\hypertarget{what-is-the-grammar-of-graphics}{%
\subsection*{What is the grammar of graphics?}\label{what-is-the-grammar-of-graphics}}
\addcontentsline{toc}{subsection}{What is the grammar of graphics?}

The structure of the ``grammar of graphics'' aims to create graphics using different layers. The grammar tells us how to map aesthetic attributes (color, shape, size) of a geometric object (points, lines, bars). We might also have a statistical transformation of the data and information about the coordinate system. Faceting is also considered. The combination of these elements make up a ``graphic''.

All plots are composed of \textbf{data} and a \textbf{mapping}.

\begin{itemize}
\item
  data: information you want to visualize
\item
  mapping: description of how the variables are mapped to aesthetic attributes.
\end{itemize}

There are five mapping components:

\begin{itemize}
\item
  \textbf{Layer}: a collect of geometric elements and statistical transformations.

  \begin{itemize}
  \item
    Geometric elements are called \textbf{geoms}, they are what you see (points, lines, etc.)
  \item
    Statistical transformations are called \textbf{stats}, they summarize the data (counting observations, makeing models)
  \end{itemize}
\item
  \textbf{Scales}: a map of the values in the data space to the aesthetic space.

  \begin{itemize}
  \item
    Modifications of the color, shape, size
  \item
    How to draw legends and axes
  \end{itemize}
\item
  \textbf{Coordinate} System: called \textbf{coord}, describe how data coordinates are mapped to the plane of the graphic.

  \begin{itemize}
  \tightlist
  \item
    Usually use Cartesian coordinate system.
  \end{itemize}
\item
  \textbf{Facet}: How to break up and display subsets of data as small multiples.
\item
  \textbf{Theme}: control other points of display, like font size, and background color.
\end{itemize}

\hypertarget{ggplot2-versus-other-r-graphics}{%
\subsection*{ggplot2 versus other R Graphics}\label{ggplot2-versus-other-r-graphics}}
\addcontentsline{toc}{subsection}{ggplot2 versus other R Graphics}

\begin{itemize}
\item
  Base R: graphics work like a ``pen on paper''
\item
  Grid: started in 2000, provided a richer system of graphics tools that are more complex.
\item
  Lattice: a new system proposed (2008ish). Uses grid graphics to implement a trellis system that populates more plotting details automatically
\item
  ggplot2: started 2005, an attempt to combine the good things about lattice and base R together using the ``grammar of graphics''
\end{itemize}

\hypertarget{getting-started-kep-components}{%
\section{Getting started: Kep Components}\label{getting-started-kep-components}}

Every ggplot2 plot has 3 key components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Data
\item
  A set of \textbf{aes}thetic mappings between variables in the data and visual properties
\item
  At least one layer which described how to render each observation. Layers are usually created with a \textbf{geom} function.
\end{enumerate}

A Basic Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg,                        }\CommentTok{# Data}
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy))}\OperatorTok{+}\StringTok{   }\CommentTok{# aesthetic mapping}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()                     }\CommentTok{# geom layer }
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-253-1.pdf}

\hypertarget{adjust-aesthetic-attributes-by-variable}{%
\section{Adjust aesthetic attributes by variable}\label{adjust-aesthetic-attributes-by-variable}}

We can adjust aesthetic attributes by variable using the \texttt{aes()} function and the \texttt{mapping} argument.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Adjust the color for each point by class}
\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{color =}\NormalTok{ class)}

\CommentTok{# Adjust the shape for each point by drv}
\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{shape =}\NormalTok{ drv)}

\CommentTok{# Adjust the size of each point by cyl}
\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{shape =}\NormalTok{ cyl)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{color =}\NormalTok{ class)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-255-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{shape =}\NormalTok{ drv)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-255-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ displ, }\DataTypeTok{y =}\NormalTok{ hwy, }\DataTypeTok{shape =} \KeywordTok{factor}\NormalTok{(cyl))) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-255-3.pdf}

\hypertarget{adjust-aesthetic-attributes-for-the-entire-plot}{%
\section{Adjust aesthetic attributes for the entire plot}\label{adjust-aesthetic-attributes-for-the-entire-plot}}

Notice that the plot changes based on if the \texttt{color} is assigned outside or inside of the \texttt{aes()} function. This is because the \texttt{aes()} function is used to map the data to an aesthetic property of the map. Inside of \texttt{aes()} we let the aesthetic argument (color, shape, etc) equal a variable in the data set. The different values for that variable control what happens to that aesthetic. If we assign aesthetic value outside of the \texttt{aes()} function then we are just assigning a value for the entire data set and do not use column names of the data.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Change aesthetic attributes according to some variable}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color =}\NormalTok{ class))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-256-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Attempt to change all points to blue Will not run}
\CommentTok{# correctly because colour = 'blue' is inside aes()}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-256-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Change all points to blue, works correctly}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-256-3.pdf}

\hypertarget{faceting}{%
\section{Faceting}\label{faceting}}

Faceting creates tables of graphics by splitting the data into subsets and displaying the same graph for each subset. You can faceting using \texttt{facet\_wrap()} which is more flexible and automatically determines how to organize the data. Or, you can manually determine the facet structure using \texttt{facet\_grid()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Facet Wrap: Let ggplot decide how many rows and columns}
\CommentTok{# to make Only give one variable to break data up by ~}
\CommentTok{# Variable}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\NormalTok{class)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-257-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Facet Grid: Number of rows and columns by number of}
\CommentTok{# unique values for variable 1 and variable 2 Row variable}
\CommentTok{# ~ Column variable.}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{facet_grid}\NormalTok{(drv }\OperatorTok{~}
\StringTok{    }\NormalTok{class)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-257-2.pdf}

\hypertarget{some-example-plots}{%
\section{Some example plots}\label{some-example-plots}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 1}
\KeywordTok{ggplot}\NormalTok{(diamonds) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_boxplot}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =}\NormalTok{ price, }\DataTypeTok{x =}\NormalTok{ cut,}
    \DataTypeTok{color =}\NormalTok{ cut))}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 2}
\KeywordTok{ggplot}\NormalTok{(diamonds) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =}\NormalTok{ price, }\DataTypeTok{x =}\NormalTok{ depth,}
    \DataTypeTok{size =}\NormalTok{ carat, }\DataTypeTok{color =}\NormalTok{ cut), }\DataTypeTok{pch =} \DecValTok{1}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{title =} \StringTok{"A Title is On This Plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 3}
\NormalTok{subgroups_diamonds <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut, clarity) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{n =} \KeywordTok{length}\NormalTok{(cut))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` regrouping output by 'cut' (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ subgroups_diamonds) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_tile}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ cut,}
    \DataTypeTok{y =}\NormalTok{ clarity, }\DataTypeTok{fill =}\NormalTok{ n)) }\OperatorTok{+}\StringTok{ }\KeywordTok{scale_fill_gradient}\NormalTok{(}\DataTypeTok{low =} \StringTok{"white"}\NormalTok{,}
    \DataTypeTok{high =} \StringTok{"purple"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-3.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 4: Method 1}
\NormalTok{subgroups_diamonds2 <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut, color) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{n =} \KeywordTok{length}\NormalTok{(cut))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` regrouping output by 'cut' (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ subgroups_diamonds2) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ cut,}
    \DataTypeTok{y =}\NormalTok{ n, }\DataTypeTok{fill =}\NormalTok{ color), }\DataTypeTok{position =} \StringTok{"fill"}\NormalTok{, }\DataTypeTok{stat =} \StringTok{"identity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-4.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 4: Method 2}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ diamonds) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ cut, }\DataTypeTok{fill =}\NormalTok{ color),}
    \DataTypeTok{position =} \StringTok{"fill"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-5.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 5}
\NormalTok{plot_data <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(clarity) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{m =} \KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(plot_data, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ clarity, }\DataTypeTok{y =}\NormalTok{ m)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{stat =} \StringTok{"identity"}\NormalTok{,}
    \DataTypeTok{show.legend =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{color =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{size =} \DecValTok{1}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-6.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 6}
\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ clarity, }\DataTypeTok{group =}\NormalTok{ cut, }\DataTypeTok{fill =}\NormalTok{ cut)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-7.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Example 7 creating dataset #1}
\NormalTok{data1 <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(clarity) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{m =} \KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{## creating dataset #2}
\NormalTok{data2 <-}\StringTok{ }\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{group_by}\NormalTok{(cut, clarity) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{m =} \KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` regrouping output by 'cut' (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{## graphing data points from 2 different datasets on one}
\CommentTok{## graph}
\KeywordTok{ggplot}\NormalTok{() }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ data1, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ clarity, }\DataTypeTok{y =}\NormalTok{ m),}
    \DataTypeTok{color =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{8}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ data2, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ clarity,}
    \DataTypeTok{y =}\NormalTok{ m), }\DataTypeTok{pch =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-258-8.pdf}

\hypertarget{where-can-i-learn-more}{%
\section{Where can I learn more?}\label{where-can-i-learn-more}}

\begin{itemize}
\item
  \url{https://ggplot2-book.org/index.html}
\item
  \url{https://www.stat.auckland.ac.nz/~ihaka/downloads/Interface98.pdf}
\item
  \url{https://hbctraining.github.io/Intro-to-R-flipped/cheatsheets/data-visualization-2.1.pdf}
\end{itemize}

\hypertarget{text-data}{%
\chapter{Text Data}\label{text-data}}

In this section we give an introduction to strings and string operations, how to extracting and manipulating string objects, and an introduction to general search methods.

We have focus on character objects in particular because a lot of the ``messy'' data comes in character form. For example, web pages can be scraped, email can be analyzed for network properties and survey responses must be processed and compared. Even if you only care about numbers, it helps to be able to extract them from text and manipulate them easily.

In general we will try to stick to the following distinction. However, many people will use the term ``character'' and ``string'' interchangeably.

\begin{itemize}
\tightlist
\item
  \textbf{\emph{Character}}: a symbol in a written language, specifically what you can enter at a keyboard: letters, numerals, punctuation, space, newlines, etc.
\end{itemize}

\begin{verbatim}
'L', 'i', 'n', 'c', 'o', 'l'
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{\emph{String}}: a sequence of characters bound together
\end{itemize}

\begin{verbatim}
Lincoln
\end{verbatim}

Note: R does not have a separate type for characters and strings

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\StringTok{"L"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\StringTok{"Lincoln"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\hypertarget{making-strings}{%
\section{Making Strings}\label{making-strings}}

Use single or double quotes to construct a string, but in general its recommeded to use double quotes. This is because the R console showcases character strings in double quotes regardless of how the string was created, and sometimes we might have single or double quotes in the string itself.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Lincoln"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Lincoln"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Lincoln"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Lincoln"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Abraham Lincoln's Hat"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Abraham Lincoln's Hat"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"As Lincoln never said, 'Four score and seven beers ago'"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "As Lincoln never said, 'Four score and seven beers ago'"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"As Lincoln never said, }\CharTok{\textbackslash{}"}\StringTok{Four score and seven beers ago}\CharTok{\textbackslash{}"}\StringTok{"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "As Lincoln never said, \"Four score and seven beers ago\""
\end{verbatim}

The space, \texttt{"\ "} is a character; so are multiple spaces \texttt{"\ \ \ "} and the empty string, \texttt{""}.

Some characters are special, so we have ``escape characters'' to specify them in strings.
- quotes within strings: \texttt{\textbackslash{}"}
- tab: \texttt{\textbackslash{}t}
- new line \texttt{\textbackslash{}n} and carriage return \texttt{\textbackslash{}r} -- use the former rather than the latter when possible.

Recall that strings (or character objects) are one of the atomic data types, like \texttt{numeric} or \texttt{logical}. Thus strings can go into scalars, vectors, arrays, lists, or be the type of a column in a data frame. We can use the \texttt{nchar()} to get the length of a single string.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(}\StringTok{"Abraham Lincoln's beard"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Abraham"}\NormalTok{, }\StringTok{"Lincoln's"}\NormalTok{, }\StringTok{"beard"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nchar}\NormalTok{(}\StringTok{"Abraham"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nchar}\NormalTok{(}\StringTok{"Abraham Lincoln's beard"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nchar}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Abraham"}\NormalTok{, }\StringTok{"Lincoln's"}\NormalTok{, }\StringTok{"beard"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7 9 5
\end{verbatim}

We can use \texttt{print()} to display the string, and \texttt{cat()} is used to write the string directly to the console. If you're debugging, \texttt{message()} is R's preferred syntax.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{presidents =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Fillmore"}\NormalTok{, }\StringTok{"Pierce"}\NormalTok{, }\StringTok{"Buchanan"}\NormalTok{, }\StringTok{"Davis"}\NormalTok{, }\StringTok{"Johnson"}\NormalTok{)}

\KeywordTok{print}\NormalTok{(}\StringTok{"Abraham Lincoln"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Abraham Lincoln"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\StringTok{"Abraham Lincoln"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Abraham Lincoln
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(presidents)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Fillmore Pierce Buchanan Davis Johnson
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{message}\NormalTok{(presidents)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## FillmorePierceBuchananDavisJohnson
\end{verbatim}

\hypertarget{substring-operations}{%
\section{Substring Operations}\label{substring-operations}}

\textbf{\emph{Substring}}: a smaller string from the big string, but still a string in its own right.

A string is not a vector or a list, so we \textbf{\emph{cannot}} use subscripts like \texttt{{[}{[}\ {]}{]}} or \texttt{{[}\ {]}} to extract substrings; we use \texttt{substr()} instead.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phrase <-}\StringTok{ "Christmas Bonus"}
\KeywordTok{substr}\NormalTok{(phrase, }\DataTypeTok{start =} \DecValTok{8}\NormalTok{, }\DataTypeTok{stop =} \DecValTok{12}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "as Bo"
\end{verbatim}

We can also use \texttt{substr} to replace elements:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(phrase, }\DecValTok{13}\NormalTok{, }\DecValTok{13}\NormalTok{) =}\StringTok{ "g"}
\NormalTok{phrase}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Christmas Bogus"
\end{verbatim}

The function \texttt{substr()} can also be used for vectors.

\texttt{substr()} vectorizes over all its arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{presidents}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore" "Pierce"   "Buchanan" "Davis"    "Johnson"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(presidents, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)  }\CommentTok{# First two characters}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fi" "Pi" "Bu" "Da" "Jo"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(presidents, }\KeywordTok{nchar}\NormalTok{(presidents) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{, }\KeywordTok{nchar}\NormalTok{(presidents))  }\CommentTok{# Last two}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "re" "ce" "an" "is" "on"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(presidents, }\DecValTok{20}\NormalTok{, }\DecValTok{21}\NormalTok{)  }\CommentTok{# No such substrings so return the null string}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "" "" "" "" ""
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(presidents, }\DecValTok{7}\NormalTok{, }\DecValTok{7}\NormalTok{)  }\CommentTok{# Explain!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "r" ""  "a" ""  "n"
\end{verbatim}

\hypertarget{dividing-strings-into-vectors}{%
\section{Dividing Strings into Vectors}\label{dividing-strings-into-vectors}}

\texttt{strsplit()} divides a string according to key characters, by splitting each element of the character vector \texttt{x} at appearances of the pattern \texttt{split}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scarborough.fair =}\StringTok{ "parsley, sage, rosemary, thyme"}
\KeywordTok{strsplit}\NormalTok{(scarborough.fair, }\StringTok{","}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "parsley"   " sage"     " rosemary" " thyme"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(scarborough.fair, }\StringTok{", "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "parsley"  "sage"     "rosemary" "thyme"
\end{verbatim}

Pattern is recycled over elements of the input vector:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(}\KeywordTok{c}\NormalTok{(scarborough.fair, }\StringTok{"Garfunkel, Oates"}\NormalTok{, }\StringTok{"Clement, McKenzie"}\NormalTok{),}
    \StringTok{", "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "parsley"  "sage"     "rosemary" "thyme"   
## 
## [[2]]
## [1] "Garfunkel" "Oates"    
## 
## [[3]]
## [1] "Clement"  "McKenzie"
\end{verbatim}

Note that it outputs a \texttt{list} of character vectors.

\hypertarget{converting-objects-into-strings}{%
\section{Converting Objects into Strings}\label{converting-objects-into-strings}}

Explicitly converting one variable type to another is called \textbf{\emph{casting}}. Notice that the number ``7.2e12'' is printed as supplied, but ``7.2e5'' is not. This is because if a number is exceeding large, small, or close to zero, then R will by default use scientific notation for that number.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\FloatTok{7.2}\NormalTok{)  }\CommentTok{# Obvious}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "7.2"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\FloatTok{7.2e+12}\NormalTok{)  }\CommentTok{# Obvious}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "7.2e+12"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\FloatTok{7.2}\NormalTok{, }\FloatTok{7.2e+12}\NormalTok{))  }\CommentTok{# Obvious}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "7.2"     "7.2e+12"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\DecValTok{720000}\NormalTok{)  }\CommentTok{# Not quite so obvious}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "720000"
\end{verbatim}

\hypertarget{versatility-of-the-paste-function}{%
\section{Versatility of the paste() Function}\label{versatility-of-the-paste-function}}

The \texttt{paste()} function is very flexible. With one vector argument, works like \texttt{as.character()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(}\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "41" "42" "43" "44" "45"
\end{verbatim}

With 2 or more vector arguments, it combines them with recycling.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore 41" "Pierce 42"   "Buchanan 43" "Davis 44"    "Johnson 45"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\KeywordTok{c}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"D"}\NormalTok{))  }\CommentTok{# Not historically accurate!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore R" "Pierce D"   "Buchanan R" "Davis D"    "Johnson R"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\StringTok{"("}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"D"}\NormalTok{), }\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{, }\StringTok{")"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore ( R 41 )" "Pierce ( D 42 )"   "Buchanan ( R 43 )"
## [4] "Davis ( D 44 )"    "Johnson ( R 45 )"
\end{verbatim}

We can changing the separator between pasted-together terms.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\StringTok{" ("}\NormalTok{, }\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{, }\StringTok{")"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"_"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore_ (_41_)" "Pierce_ (_42_)"   "Buchanan_ (_43_)" "Davis_ (_44_)"   
## [5] "Johnson_ (_45_)"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\StringTok{" ("}\NormalTok{, }\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{, }\StringTok{")"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore (41)" "Pierce (42)"   "Buchanan (43)" "Davis (44)"   
## [5] "Johnson (45)"
\end{verbatim}

We can also condense multiple strings together using the \texttt{collapse} argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(presidents, }\StringTok{" ("}\NormalTok{, }\DecValTok{41}\OperatorTok{:}\DecValTok{45}\NormalTok{, }\StringTok{")"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{, }\DataTypeTok{collapse =} \StringTok{"; "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Fillmore (41); Pierce (42); Buchanan (43); Davis (44); Johnson (45)"
\end{verbatim}

Default value of \texttt{collapse} is \texttt{NULL} -- that is, it won't use it.

\hypertarget{gsub-sub}{%
\section{gsub , sub}\label{gsub-sub}}

gsub is all occurances, and sub is first occurance.

\hypertarget{text-of-some-importance}{%
\section{Text of Some Importance}\label{text-of-some-importance}}

Consider the following quote from Abraham Lincoln. Often times we will want to study or analyze a block of text. To

\begin{quote}
``If we shall suppose that American slavery is one of those
offenses which, in the providence of God, must needs come, but which, having
continued through His appointed time, He now wills to remove, and that He
gives to both North and South this terrible war as the woe due to those by
whom the offense came, shall we discern therein any departure from those
divine attributes which the believers in a living God always ascribe to Him?
Fondly do we hope, fervently do we pray, that this mighty scourge of war may
speedily pass away. Yet, if God wills that it continue until all the wealth
piled by the bondsman's two hundred and fifty years of unrequited toil shall
be sunk, and until every drop of blood drawn with the lash shall be paid by
another drawn with the sword, as was said three thousand years ago, so still
it must be said''the judgments of the Lord are true and righteous
altogether."
\end{quote}

We can read in the file with the following commands.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{the_url <-}\StringTok{ "https://raw.githubusercontent.com/rpkgarcia/LearnRBook/main/data_sets/al1.txt"}
\NormalTok{al1 <-}\StringTok{ }\KeywordTok{readLines}\NormalTok{(the_url, }\DataTypeTok{warn =} \OtherTok{FALSE}\NormalTok{)}

\CommentTok{# How many lines in the file}
\KeywordTok{length}\NormalTok{(al1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# See the object}
\NormalTok{al1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "If we shall suppose that American slavery is one of those offenses which, in the providence of God, must needs come, but which, having continued through His appointed time, He now wills to remove, and that He gives to both North and South this terrible war as the woe due to those by whom the offense came, shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope, fervently do we pray, that this mighty scourge of war may speedily pass away. Yet, if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk, and until every drop of blood drawn with the lash shall be paid by another drawn with the sword, as was said three thousand years ago, so still it must be said “the judgments of the Lord are true and righteous altogether”."
\end{verbatim}

Lets create a new vector where each element is a portion of text seperated by a comman ``,''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{al1.phrases <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(al1, }\StringTok{","}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{al1.phrases}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "If we shall suppose that American slavery is one of those offenses which"                                                                         
##  [2] " in the providence of God"                                                                                                                        
##  [3] " must needs come"                                                                                                                                 
##  [4] " but which"                                                                                                                                       
##  [5] " having continued through His appointed time"                                                                                                     
##  [6] " He now wills to remove"                                                                                                                          
##  [7] " and that He gives to both North and South this terrible war as the woe due to those by whom the offense came"                                    
##  [8] " shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope"
##  [9] " fervently do we pray"                                                                                                                            
## [10] " that this mighty scourge of war may speedily pass away. Yet"                                                                                     
## [11] " if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk"         
## [12] " and until every drop of blood drawn with the lash shall be paid by another drawn with the sword"                                                 
## [13] " as was said three thousand years ago"                                                                                                            
## [14] " so still it must be said “the judgments of the Lord are true and righteous altogether”."
\end{verbatim}

\hypertarget{search}{%
\section{Search}\label{search}}

We can search through text strings for certain patterns. Some particularly helpful functions for doing this are \texttt{grep()} and \texttt{grepl()}. The \texttt{grep()} function

Narrowing down entries: use \texttt{grep()} to find which strings have a matching search term

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns indices for which element in al1 has the term}
\CommentTok{# 'God'}
\KeywordTok{grep}\NormalTok{(}\StringTok{"God"}\NormalTok{, al1.phrases)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2  8 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns T/F values for which indices have the term 'God'}
\KeywordTok{grepl}\NormalTok{(}\StringTok{"God"}\NormalTok{, al1.phrases)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE
## [13] FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Returns the the elements in al1 that have the term 'God'}
\NormalTok{al1.phrases[}\KeywordTok{grep}\NormalTok{(}\StringTok{"God"}\NormalTok{, al1.phrases)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] " in the providence of God"                                                                                                                        
## [2] " shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope"
## [3] " if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk"
\end{verbatim}

\hypertarget{word-count-tables}{%
\section{Word Count Tables}\label{word-count-tables}}

Now lets break up the data set by spaces. We do this in hopes that it will separate each word as an element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{al1.words <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(al1, }\DataTypeTok{split =} \StringTok{" "}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
\KeywordTok{head}\NormalTok{(al1.words)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "If"       "we"       "shall"    "suppose"  "that"     "American"
\end{verbatim}

We can now tabulate how often each word appears using the \texttt{table()} function. Then we can sort the frequencies in order using \texttt{sort()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wc <-}\StringTok{ }\KeywordTok{table}\NormalTok{(al1.words)}
\NormalTok{wc <-}\StringTok{ }\KeywordTok{sort}\NormalTok{(wc, }\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{head}\NormalTok{(wc, }\DecValTok{250}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## al1.words
##          the           of          and        shall         that           to 
##            9            6            5            4            4            4 
##           we           be           by        those           as           do 
##            4            3            3            3            2            2 
##        drawn          God           He           in           it         must 
##            2            2            2            2            2            2 
##         said         this        until          war       which,        wills 
##            2            2            2            2            2            2 
##         with        years         “the            a         ago,          all 
##            2            2            1            1            1            1 
## altogether”.       always     American      another          any    appointed 
##            1            1            1            1            1            1 
##          are      ascribe   attributes        away.    believers        blood 
##            1            1            1            1            1            1 
##   bondsman’s         both          but        came,        come,     continue 
##            1            1            1            1            1            1 
##    continued    departure      discern       divine         drop          due 
##            1            1            1            1            1            1 
##        every    fervently        fifty       Fondly         from        gives 
##            1            1            1            1            1            1 
##         God,       having         Him?          His        hope,      hundred 
##            1            1            1            1            1            1 
##           if           If           is    judgments         lash       living 
##            1            1            1            1            1            1 
##         Lord          may       mighty        needs        North          now 
##            1            1            1            1            1            1 
##      offense     offenses          one         paid         pass        piled 
##            1            1            1            1            1            1 
##        pray,   providence      remove,    righteous      scourge      slavery 
##            1            1            1            1            1            1 
##           so        South     speedily        still        sunk,      suppose 
##            1            1            1            1            1            1 
##       sword,     terrible      therein     thousand        three      through 
##            1            1            1            1            1            1 
##        time,         toil         true          two   unrequited          was 
##            1            1            1            1            1            1 
##       wealth        which         whom          woe         Yet, 
##            1            1            1            1            1
\end{verbatim}

Notice that punctuation using these methods is still present.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# These are different}
\NormalTok{wc[}\StringTok{"He"}\NormalTok{]  }\CommentTok{# exists}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## He 
##  2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wc[}\StringTok{"he"}\NormalTok{]  }\CommentTok{# does not exist}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <NA> 
##   NA
\end{verbatim}

In addition, all our words and string subsets are case sensitive.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# What happens when we look for a word that is not in our}
\CommentTok{# word count table?}

\KeywordTok{which}\NormalTok{(}\KeywordTok{names}\NormalTok{(wc) }\OperatorTok{==}\StringTok{ "That"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## integer(0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wc[}\StringTok{"That"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <NA> 
##   NA
\end{verbatim}

\hypertarget{apply}{%
\chapter{Apply Family of Functions}\label{apply}}

Loops (like \texttt{for}, and \texttt{while}) are a way to repeatedly execute some code. However, they are often slow in execution when it comes to processing large data sets.

\texttt{R} has a more efficient and quick approach to perform iterations -- \textbf{The apply family}.

The apply family consists of vectorized functions. Below are the most common forms of apply functions.

\begin{itemize}
\tightlist
\item
  \texttt{apply()}
\item
  \texttt{lapply()}
\item
  \texttt{sapply()}
\item
  \texttt{tapply()}
\item
  \texttt{mapply()}
\item
  \texttt{replicate()}
\end{itemize}

These functions let you take data in batches and process the whole batch at once.

There primary difference is in the object (such as list, matrix, data frame etc.) on which the function is applied to and the object that will be returned from the function.

These functions apply a function to different components of a vector/list/dataframe/array in a non-sequential way. In general, if each element in your object is not dependent on the other elements of your object then an apply function is usually faster than a loop.

\begin{center}\includegraphics[width=0.3\linewidth]{images/lapplyGraphic} \end{center}

\hypertarget{apply-1}{%
\section{apply()}\label{apply-1}}

The \texttt{apply()}function is used to apply a function to the rows or columns of arrays (matrices). It assembles the returned values, and then returns it in a vector, array, or list.

If you want to apply a function on a data frame, make sure that the data frame is homogeneous (i.e.~either all numeric values or all character strings). Otherwise, R will force all columns to have identical types using \texttt{as.matrix()}. This may not be what you want. In that case, you might consider using the \texttt{lapply()} or \texttt{sapply()} functions instead.

Description of the required \texttt{apply()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{X}: A array (or matrix)
\item
  \texttt{MARGIN}: A vector giving the subscripts which the function will be applied over.

  \begin{itemize}
  \tightlist
  \item
    1 indicates rows
  \item
    2 indicates columns
  \item
    c(1, 2) indicates rows and columns
  \end{itemize}
\item
  \texttt{FUN}: The function to be applied
\item
  \texttt{...}: Additional arguments to be passed to ``FUN''
\end{itemize}

\hypertarget{example-built-in-function}{%
\subsection*{Example: Built In Function}\label{example-built-in-function}}
\addcontentsline{toc}{subsection}{Example: Built In Function}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Get column means}
\NormalTok{data <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(data, }\DecValTok{2}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 5 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Get row means}
\KeywordTok{apply}\NormalTok{(data, }\DecValTok{1}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12 15 18
\end{verbatim}

\hypertarget{example-user-defined-function}{%
\subsection*{Example: User Defined Function}\label{example-user-defined-function}}
\addcontentsline{toc}{subsection}{Example: User Defined Function}

You can use user-defined functions as well.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(data, }\DecValTok{2}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}

    \CommentTok{# Standard deviation formula}
\NormalTok{    y <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{^}\DecValTok{2}\OperatorTok{/}\NormalTok{(}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}

    \KeywordTok{return}\NormalTok{(y)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 0
\end{verbatim}

\hypertarget{returned-objects}{%
\subsection{Returned Objects}\label{returned-objects}}

The values that \texttt{apply()} returns depends on the function \texttt{FUN}. If \texttt{FUN} returns an element of length 1, then \texttt{apply()} will return a vector. If \texttt{FUN} \emph{always} returns an element of length \texttt{n}\textgreater1, then \texttt{apply()} will return a matrix with \texttt{n} rows, and the number of columns will correspond to how many rows/columns were iterated over. Lastly, if \texttt{FUN} returns an object that would vary in length, then \texttt{apply()} will return a list where each element corresponds to a row or column that was iterated over. In short, \texttt{apply()} prioritizes returning a vector, array (or matrix), and list (in that order). What is returned depends on the output of \texttt{FUN}.

\hypertarget{example-extra-arguments-array-output}{%
\subsection{Example: Extra Arguments, Array Output}\label{example-extra-arguments-array-output}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(}\DataTypeTok{x1 =} \DecValTok{3}\NormalTok{, }\DataTypeTok{x2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{4}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{5}\NormalTok{))}

\NormalTok{fun1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, c1, c2) \{}
\NormalTok{    mean_vec <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x[c1]), }\KeywordTok{mean}\NormalTok{(x[c2]))}
    \KeywordTok{return}\NormalTok{(mean_vec)}
\NormalTok{\}}

\KeywordTok{apply}\NormalTok{(x, }\DecValTok{1}\NormalTok{, fun1, }\DataTypeTok{c1 =} \StringTok{"x1"}\NormalTok{, }\DataTypeTok{c2 =} \KeywordTok{c}\NormalTok{(}\StringTok{"x1"}\NormalTok{, }\StringTok{"x2"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]  3.0    3  3.0    3  3.0    3  3.0    3
## [2,]  3.5    3  2.5    2  2.5    3  3.5    4
\end{verbatim}

\hypertarget{example-list-output}{%
\subsection{Example: List Output}\label{example-list-output}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{-2}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{-2}\NormalTok{, }\DecValTok{-6}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}

\NormalTok{CheckPos <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(Vec) \{}
    \CommentTok{# Subset values of Vec that are even}
\NormalTok{    PosVec <-}\StringTok{ }\NormalTok{Vec[Vec }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{]}

    \CommentTok{# Return only the even values}
    \KeywordTok{return}\NormalTok{(PosVec)}
\NormalTok{\}}

\CommentTok{# Check Positive values by column}
\KeywordTok{apply}\NormalTok{(mat, }\DecValTok{2}\NormalTok{, CheckPos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1]  2 20
## 
## [[3]]
## [1] 62
\end{verbatim}

\hypertarget{lapply}{%
\section{lapply()}\label{lapply}}

The \texttt{lapply()} function is used to apply a function to each element of the list. It collects the returned values into a list, and then \textbf{returns that list} which is of the same length.

Description of the required \texttt{lapply()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{X}: A list
\item
  \texttt{FUN}: The function to be applied
\item
  \texttt{...}: Additional arguments to be passed to \texttt{FUN}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{item1 =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{item2 =} \KeywordTok{seq}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{36}\NormalTok{, }\DecValTok{8}\NormalTok{), }\DataTypeTok{item3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}
    \DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{))}
\NormalTok{data_lst}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $item1
## [1] 1 2 3 4 5
## 
## $item2
## [1]  4 12 20 28 36
## 
## $item3
## [1] 1 3 5 7 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\NormalTok{data_vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 5 6 7 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(data_lst, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $item1
## [1] 15
## 
## $item2
## [1] 100
## 
## $item3
## [1] 25
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(data_vector, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 4
## 
## [[5]]
## [1] 5
## 
## [[6]]
## [1] 6
## 
## [[7]]
## [1] 7
## 
## [[8]]
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{beta =} \KeywordTok{exp}\NormalTok{(}\OperatorTok{-}\DecValTok{3}\OperatorTok{:}\DecValTok{3}\NormalTok{), }\DataTypeTok{logic =} \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{,}
    \OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{))}

\CommentTok{# compute the list mean for each list element}
\KeywordTok{lapply}\NormalTok{(x, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $a
## [1] 5.5
## 
## $beta
## [1] 4.535125
## 
## $logic
## [1] 0.5
\end{verbatim}

Unlike \texttt{apply()}, \texttt{lapply()} will always return a list. If the argument \texttt{X} is an object that is something other than a list then the \texttt{as.list()} function will be used to convert that object. Consider the built-in data set \texttt{iris} in R. If we use the \texttt{as.list()} function, each column will be converted into an element of a list.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(iris))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 5
##  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
##  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
##  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
##  $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
##  $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
\end{verbatim}

Then if we use \texttt{lapply()} it will iterate over the columns. We can find all values within a column that are bigger than the column mean (just looking at the numeric columns though).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(iris[, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{], }\ControlFlowTok{function}\NormalTok{(column) \{}
\NormalTok{    big_values <-}\StringTok{ }\NormalTok{column[column }\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(column)]}
    \KeywordTok{return}\NormalTok{(big_values)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $Sepal.Length
##  [1] 7.0 6.4 6.9 6.5 6.3 6.6 5.9 6.0 6.1 6.7 6.2 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7
## [20] 6.0 6.0 6.0 6.7 6.3 6.1 6.2 6.3 7.1 6.3 6.5 7.6 7.3 6.7 7.2 6.5 6.4 6.8 6.4
## [39] 6.5 7.7 7.7 6.0 6.9 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7
## [58] 6.3 6.4 6.0 6.9 6.7 6.9 6.8 6.7 6.7 6.3 6.5 6.2 5.9
## 
## $Sepal.Width
##  [1] 3.5 3.2 3.1 3.6 3.9 3.4 3.4 3.1 3.7 3.4 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6
## [20] 3.3 3.4 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.4 3.5 3.2 3.5 3.8
## [39] 3.8 3.2 3.7 3.3 3.2 3.2 3.1 3.3 3.1 3.2 3.4 3.1 3.3 3.6 3.2 3.2 3.8 3.2 3.3
## [58] 3.2 3.8 3.4 3.1 3.1 3.1 3.1 3.2 3.3 3.4
## 
## $Petal.Length
##  [1] 4.7 4.5 4.9 4.0 4.6 4.5 4.7 4.6 3.9 4.2 4.0 4.7 4.4 4.5 4.1 4.5 3.9 4.8 4.0
## [20] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.8 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0 4.4 4.6 4.0
## [39] 4.2 4.2 4.2 4.3 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 5.8 6.1 5.1 5.3 5.5 5.0
## [58] 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 4.8 4.9 5.6 5.8 6.1 6.4 5.6
## [77] 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 5.7 5.2 5.0 5.2 5.4 5.1
## 
## $Petal.Width
##  [1] 1.4 1.5 1.5 1.3 1.5 1.3 1.6 1.3 1.4 1.5 1.4 1.3 1.4 1.5 1.5 1.8 1.3 1.5 1.2
## [20] 1.3 1.4 1.4 1.7 1.5 1.2 1.6 1.5 1.6 1.5 1.3 1.3 1.3 1.2 1.4 1.2 1.3 1.2 1.3
## [39] 1.3 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 1.8
## [58] 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3
## [77] 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3 2.5 2.3 1.9 2.0 2.3 1.8
\end{verbatim}

\hypertarget{sapply}{%
\section{sapply()}\label{sapply}}

The \texttt{sapply()} and \texttt{lapply()} work basically the same.

The only difference is that \texttt{lapply()} always returns a list, whereas \texttt{sapply()} tries to simplify the result into a vector or matrix. The output for \texttt{sapply()} is just like the output of \texttt{apply()}, it depends on the dimensions of the returned value for \texttt{FUN}.

\begin{itemize}
\item
  If the return value is a list where every element is length 1, you get a vector.
\item
  If the return value is a list where every element is a vector of the same length (\textgreater{} 1), you get a matrix.
\item
  If the lengths vary, simplification is impossible and you get a list.
\end{itemize}

Description of the required \texttt{sapply()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{X}: A list
\item
  \texttt{FUN}: The function to be applied
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_lst <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{item1 =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{item2 =} \KeywordTok{seq}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{36}\NormalTok{, }\DecValTok{8}\NormalTok{), }\DataTypeTok{item3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}
    \DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{))}
\NormalTok{data_lst}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $item1
## [1] 1 2 3 4 5
## 
## $item2
## [1]  4 12 20 28 36
## 
## $item3
## [1] 1 3 5 7 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(data_lst, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## item1 item2 item3 
##    15   100    25
\end{verbatim}

\hypertarget{tapply}{%
\section{tapply()}\label{tapply}}

The \texttt{tapply()} function breaks the data set up into groups and applies a function to each group.

Description of the required \texttt{sapply()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{X}: A 1 dimensional object
\item
  \texttt{INDEX}: A grouping factor or a list of factors
\item
  \texttt{FUN}: The function to be applied
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{name =} \KeywordTok{c}\NormalTok{(}\StringTok{"Amy"}\NormalTok{, }\StringTok{"Max"}\NormalTok{, }\StringTok{"Ray"}\NormalTok{, }\StringTok{"Kim"}\NormalTok{, }\StringTok{"Sam"}\NormalTok{,}
    \StringTok{"Eve"}\NormalTok{, }\StringTok{"Bob"}\NormalTok{), }\DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{24}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{21}\NormalTok{), }\DataTypeTok{gender =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}
    \StringTok{"M"}\NormalTok{, }\StringTok{"M"}\NormalTok{, }\StringTok{"F"}\NormalTok{, }\StringTok{"M"}\NormalTok{, }\StringTok{"F"}\NormalTok{, }\StringTok{"M"}\NormalTok{)))}

\NormalTok{data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   name age gender
## 1  Amy  24      F
## 2  Max  22      M
## 3  Ray  21      M
## 4  Kim  23      F
## 5  Sam  20      M
## 6  Eve  24      F
## 7  Bob  21      M
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(data}\OperatorTok{$}\NormalTok{age, data}\OperatorTok{$}\NormalTok{gender, min)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  F  M 
## 23 20
\end{verbatim}

\hypertarget{mapply}{%
\section{mapply()}\label{mapply}}

The \texttt{mapply()} function is a multivariate version of \texttt{sapply()}. It applies \texttt{FUN} to the first elements of each \ldots{} argument, the second elements, the third elements, and so on.

Description of the required \texttt{mapply()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{FUN}: The function to be applied
\item
  \texttt{...}: Arguments to vectorize over (vectors or lists of strictly positive length, or all of zero length).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mapply}\NormalTok{(rep, }\DataTypeTok{times =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{x =} \DecValTok{4}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 4
## 
## [[2]]
## [1] 3 3
## 
## [[3]]
## [1] 2 2 2
## 
## [[4]]
## [1] 1 1 1 1
\end{verbatim}

\hypertarget{replicate-1}{%
\section{replicate()}\label{replicate-1}}

The \texttt{replicate()} function is a wrapper for \texttt{sapply()}. If we want to repeat an evaluation of an function call or an expression that does not require us to iterate through a data set or vector we can use \texttt{replicate()}.

Description of the required \texttt{replicate()} arguments:

\begin{itemize}
\tightlist
\item
  \texttt{n}: An integer containing the number of replications.
\item
  \texttt{expr}: The expression (or function call) to evaluate repeatedly.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{replicate}\NormalTok{(}\DataTypeTok{n =} \DecValTok{4}\NormalTok{, }\StringTok{"Hello"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello" "Hello" "Hello" "Hello"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{replicate}\NormalTok{(}\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\KeywordTok{factorial}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 24 24 24 24 24 24 24 24 24 24
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{replicate}\NormalTok{(}\DataTypeTok{n =} \DecValTok{5}\NormalTok{, }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"blue"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]   [,2]   [,3]   [,4]   [,5]  
## [1,] "blue" "red"  "red"  "red"  "red" 
## [2,] "red"  "blue" "blue" "blue" "blue"
\end{verbatim}

\hypertarget{how-to-pick-a-method}{%
\section{How to Pick a Method}\label{how-to-pick-a-method}}

It can be difficult at first to decide which of these apply function you may want to use. In general, we can use the flow chart below as a quick guide.

\includegraphics{images/apply_flowchart.png}

\hypertarget{more-examples}{%
\section{More Examples}\label{more-examples}}

To see some more examples of these functions in action. We will use the \texttt{iris} data set which is a built in data set in R. This data set has four numeric columns, and one factor column, \texttt{Species}. Each row is a flower, and there are four different measurements of each flower.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  
##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  
##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  
##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  
##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  
##        Species  
##  setosa    :50  
##  versicolor:50  
##  virginica :50  
##                 
##                 
## 
\end{verbatim}

Find the maximum value for the numeric variables for each observation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numeric_iris <-}\StringTok{ }\NormalTok{iris[, }\DecValTok{-5}\NormalTok{]}
\NormalTok{max_in_row <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(numeric_iris, }\DecValTok{1}\NormalTok{, max)}
\KeywordTok{head}\NormalTok{(max_in_row)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.1 4.9 4.7 4.6 5.0 5.4
\end{verbatim}

Determine the (arithmetic) mean of the sepal width for each species.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean_species <-}\StringTok{ }\KeywordTok{tapply}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Width, }\DataTypeTok{INDEX =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Species,}
\NormalTok{    mean)}
\NormalTok{mean_species}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     setosa versicolor  virginica 
##      3.428      2.770      2.974
\end{verbatim}

Determine the (arithmetic) mean and the median of sepal width for each species.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_avgs <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(vec) \{}
\NormalTok{    the_mean <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(vec)}
\NormalTok{    the_median <-}\StringTok{ }\KeywordTok{median}\NormalTok{(vec)}
\NormalTok{    return_object <-}\StringTok{ }\KeywordTok{c}\NormalTok{(the_mean, the_median)}
    \KeywordTok{names}\NormalTok{(return_object) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{)}
    \KeywordTok{return}\NormalTok{(return_object)}
\NormalTok{\}}

\NormalTok{species_avgs <-}\StringTok{ }\KeywordTok{tapply}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Width, iris}\OperatorTok{$}\NormalTok{Species, my_avgs)}
\NormalTok{species_avgs}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $setosa
##   mean median 
##  3.428  3.400 
## 
## $versicolor
##   mean median 
##   2.77   2.80 
## 
## $virginica
##   mean median 
##  2.974  3.000
\end{verbatim}

Make a plot of the sepal width and sepal length. Make the points differ depending on the species type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Starting plot, make it blank}
\KeywordTok{plot}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length, iris}\OperatorTok{$}\NormalTok{Sepal.Width, }\DataTypeTok{col =} \StringTok{"white"}\NormalTok{)}


\CommentTok{# Custom function to add the points}
\NormalTok{add_points <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(the_data, ...) \{}

    \ControlFlowTok{if}\NormalTok{ (the_data[}\DecValTok{5}\NormalTok{] }\OperatorTok{==}\StringTok{ "setosa"}\NormalTok{) \{}
        \KeywordTok{points}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ the_data[}\DecValTok{1}\NormalTok{], }\DataTypeTok{y =}\NormalTok{ the_data[}\DecValTok{2}\NormalTok{], }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{,}
            \DataTypeTok{pch =} \DecValTok{0}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (the_data[}\DecValTok{5}\NormalTok{] }\OperatorTok{==}\StringTok{ "virginica"}\NormalTok{) \{}
        \KeywordTok{points}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ the_data[}\DecValTok{1}\NormalTok{], }\DataTypeTok{y =}\NormalTok{ the_data[}\DecValTok{2}\NormalTok{], }\DataTypeTok{col =} \StringTok{"blue"}\NormalTok{,}
            \DataTypeTok{pch =} \DecValTok{2}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{points}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ the_data[}\DecValTok{1}\NormalTok{], }\DataTypeTok{y =}\NormalTok{ the_data[}\DecValTok{2}\NormalTok{], }\DataTypeTok{col =} \StringTok{"green"}\NormalTok{,}
            \DataTypeTok{pch =} \DecValTok{10}\NormalTok{)}

\NormalTok{    \}}
\NormalTok{\}}


\CommentTok{# Use apply to add points}
\KeywordTok{apply}\NormalTok{(iris, }\DecValTok{1}\NormalTok{, add_points)}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-298-1.pdf}

\begin{verbatim}
## NULL
\end{verbatim}

Make a plot of the sepal width and sepal length. Make the points differ depending on the species type. Add the (arithmetic) mean of these two variables for each group.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ------ PLOT FROM BEFORE Starting plot, make it blank}
\KeywordTok{plot}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length, iris}\OperatorTok{$}\NormalTok{Sepal.Width, }\DataTypeTok{col =} \StringTok{"white"}\NormalTok{)}
\KeywordTok{apply}\NormalTok{(iris, }\DecValTok{1}\NormalTok{, add_points)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ------}


\CommentTok{# Split the data into a list by factor}
\NormalTok{split_iris =}\StringTok{ }\KeywordTok{split}\NormalTok{(iris, }\DataTypeTok{f =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Species)}

\CommentTok{# Iterate through the list and add (black) points to the}
\CommentTok{# plot}
\KeywordTok{lapply}\NormalTok{(split_iris, }\ControlFlowTok{function}\NormalTok{(species_data) \{}
    \KeywordTok{points}\NormalTok{(}\KeywordTok{mean}\NormalTok{(species_data}\OperatorTok{$}\NormalTok{Sepal.Length), }\KeywordTok{mean}\NormalTok{(species_data}\OperatorTok{$}\NormalTok{Sepal.Width),}
        \DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\includegraphics{_main_files/figure-latex/unnamed-chunk-299-1.pdf}

\begin{verbatim}
## $setosa
## NULL
## 
## $versicolor
## NULL
## 
## $virginica
## NULL
\end{verbatim}

Lets try using another example. Suppose we wish to use the following formula (below) with \texttt{a\ =\ Sepal.Length}, \texttt{b\ =\ Sepal.Width}, and \texttt{c\ =\ Petal.Length}.
\[ \frac{-b + \sqrt{b^2-4ac} }{2a}\]

Now there is more efficient ways to do this in R, but lets practice how we would do it with \texttt{mapply} as an example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_formula <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b, c) \{}
\NormalTok{    num <-}\StringTok{ }\NormalTok{(}\OperatorTok{-}\NormalTok{b }\OperatorTok{+}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(b}\OperatorTok{^}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{4} \OperatorTok{*}\StringTok{ }\NormalTok{a }\OperatorTok{*}\StringTok{ }\NormalTok{c))}
\NormalTok{    den <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{a}

\NormalTok{    answer <-}\StringTok{ }\NormalTok{num}\OperatorTok{/}\NormalTok{den}
    \KeywordTok{return}\NormalTok{(answer)}
\NormalTok{\}}

\NormalTok{formula_results <-}\StringTok{ }\KeywordTok{mapply}\NormalTok{(my_formula, }\DataTypeTok{a =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Sepal.Length,}
    \DataTypeTok{b =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Sepal.Width, }\DataTypeTok{c =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Petal.Length)}
\KeywordTok{head}\NormalTok{(formula_results)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2831638 0.3098526 0.2860609 0.3260870 0.2800000 0.3061340
\end{verbatim}

\hypertarget{create-a-new-variable}{%
\subsection{Create a New Variable}\label{create-a-new-variable}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{petal_size <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(PLength, BigCutOff, ModerateCutOff, SmallCutOff)\{}
  \ControlFlowTok{if}\NormalTok{(PLength }\OperatorTok{>}\StringTok{ }\NormalTok{BigCutOff)\{}
\NormalTok{    PetalSize <-}\StringTok{ "Big"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (PLength }\OperatorTok{>}\StringTok{ }\NormalTok{ModerateCutOff)\{}
\NormalTok{    PetalSize <-}\StringTok{ "Moderate"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(PLength }\OperatorTok{>}\StringTok{ }\NormalTok{SmallCutOff)\{}
\NormalTok{    PetalSize <-}\StringTok{ "Small"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    PetalSize <-}\StringTok{ "Very Small"}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(PetalSize)}
\NormalTok{\}}

\KeywordTok{sapply}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length,   }\CommentTok{# Data}
\NormalTok{       petal_size,          }\CommentTok{# Function}
       \DataTypeTok{BigCutOff =} \DecValTok{5}\NormalTok{,       }\CommentTok{# Optional Arguments for function}
       \DataTypeTok{ModerateCutOff =} \DecValTok{4}\NormalTok{, }
       \DataTypeTok{SmallCutOff =} \FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] "Very Small" "Very Small" "Very Small" "Very Small" "Very Small"
##   [6] "Small"      "Very Small" "Very Small" "Very Small" "Very Small"
##  [11] "Very Small" "Small"      "Very Small" "Very Small" "Very Small"
##  [16] "Very Small" "Very Small" "Very Small" "Small"      "Very Small"
##  [21] "Small"      "Very Small" "Very Small" "Small"      "Small"     
##  [26] "Small"      "Small"      "Very Small" "Very Small" "Small"     
##  [31] "Small"      "Very Small" "Very Small" "Very Small" "Very Small"
##  [36] "Very Small" "Very Small" "Very Small" "Very Small" "Very Small"
##  [41] "Very Small" "Very Small" "Very Small" "Small"      "Small"     
##  [46] "Very Small" "Small"      "Very Small" "Very Small" "Very Small"
##  [51] "Moderate"   "Moderate"   "Moderate"   "Small"      "Moderate"  
##  [56] "Moderate"   "Moderate"   "Small"      "Moderate"   "Small"     
##  [61] "Small"      "Moderate"   "Small"      "Moderate"   "Small"     
##  [66] "Moderate"   "Moderate"   "Moderate"   "Moderate"   "Small"     
##  [71] "Moderate"   "Small"      "Moderate"   "Moderate"   "Moderate"  
##  [76] "Moderate"   "Moderate"   "Moderate"   "Moderate"   "Small"     
##  [81] "Small"      "Small"      "Small"      "Big"        "Moderate"  
##  [86] "Moderate"   "Moderate"   "Moderate"   "Moderate"   "Small"     
##  [91] "Moderate"   "Moderate"   "Small"      "Small"      "Moderate"  
##  [96] "Moderate"   "Moderate"   "Moderate"   "Small"      "Moderate"  
## [101] "Big"        "Big"        "Big"        "Big"        "Big"       
## [106] "Big"        "Moderate"   "Big"        "Big"        "Big"       
## [111] "Big"        "Big"        "Big"        "Moderate"   "Big"       
## [116] "Big"        "Big"        "Big"        "Big"        "Moderate"  
## [121] "Big"        "Moderate"   "Big"        "Moderate"   "Big"       
## [126] "Big"        "Moderate"   "Moderate"   "Big"        "Big"       
## [131] "Big"        "Big"        "Big"        "Big"        "Big"       
## [136] "Big"        "Big"        "Big"        "Moderate"   "Big"       
## [141] "Big"        "Big"        "Big"        "Big"        "Big"       
## [146] "Big"        "Moderate"   "Big"        "Big"        "Big"
\end{verbatim}

\hypertarget{additional-resources-7}{%
\section*{Additional Resources}\label{additional-resources-7}}
\addcontentsline{toc}{section}{Additional Resources}

\begin{itemize}
\tightlist
\item
  \url{http://adv-r.had.co.nz/Functionals.html}
\end{itemize}

\hypertarget{debugging}{%
\chapter{Debugging}\label{debugging}}

\begin{center}\includegraphics[width=0.25\linewidth]{images/moth} \end{center}

\hypertarget{debugging-background-history-types-of-bugs-challenges-to-consider}{%
\section{Debugging Background (History, Types of Bugs, Challenges to Consider)}\label{debugging-background-history-types-of-bugs-challenges-to-consider}}

Debugging is the process of finding and resolving defects or problems within a computer program that prevent correct operation of computer software or a system.

History of the term:

\begin{itemize}
\item
  Admiral Grace Hopper used the term while working on a Mark II computer at Harvard University in the 1940s , her associates discovered a moth stuck in a relay which prevented it from working, whereupon she remarked that they were `debugging' the system.
\item
  The term `bug', in the sense of `technical error', dates back at least to 1878 with Thomas Edison.
\item
  `Debugging' used in reference to airplane engine testing in 1945.
\end{itemize}

Debugging ranges in complexity from fixing simple errors to performing lengthy and tiresome tasks. Certain programs make debugging easier with built in functions, warning messages, and error messages. Warning/error messages often only reveal the presence of problems, but doesn't tell us what the problems are, or how the code needs to be fixed. \textbf{In other words, testing reveals the effects (or symptoms) of errors, not the cause of errors.}

When a human or animal is sick or in pain, they go see a doctor. They tell the doctor what are the issues they are experiencing: a headache, a pain in their leg, sneezing, etc. The doctor takes this information, they may do additional tests or an exam, and then the doctor determines the problem. Once the doctor determines the problem, a treatment is recommended. Debugging is similar to this process, where R (or your computer) is the patient, and you (the programmer) are the doctor. R will give the programmer an error or warning message telling you were the compiler had an issue executing the commands. This message may not actually be the route of the problem though. For example, sometimes a patient goes to the doctor complaining of a pain in their leg, but the doctor determines that it is their back that is injured and a muscle connected to their back is causing the pain. When R gives you this warning or error message, it is describing a \textbf{symptom}, not the actual problem. It is your job to determine the problem, and then determine the solution (or the treatment). Often times knowing the symptom is not enough to determine the problem or the solution, which we see in the medical practice as well. Additional tests or further analysis is needed. We can use the debugging strategies described below which can help us further determine what the problem is.

We will focus on techniques in R, but several of these techniques and be generalized to other languages.

\hypertarget{types-of-bugs}{%
\subsection*{Types of bugs}\label{types-of-bugs}}
\addcontentsline{toc}{subsection}{Types of bugs}

\begin{itemize}
\item
  \textbf{Syntax or type errors}. Wrong spelling or punctuation. Example: forgetting a semi-colon or not starting a new line of code.
\item
  \textbf{Typos}. Missing parentheses, order of operations, wrong object name. Often caught by compilers.
\item
  \textbf{Implementation errors}. Inputting the wrong data type into a function.
\item
  \textbf{Logical errors}. Algorithm/function does not work on all cases. Logical flaw in design or structure. Hard to detect.
\end{itemize}

\hypertarget{debugging-process-difficulties}{%
\subsection*{Debugging Process Difficulties}\label{debugging-process-difficulties}}
\addcontentsline{toc}{subsection}{Debugging Process Difficulties}

\begin{itemize}
\item
  \textbf{The symptoms may not give clear indications about the cause}. Error/Warning messages may not give a clear indication of true problem.
\item
  \textbf{Symptoms may be difficult to reproduce}. Symptoms or errors maybe different or nonexistent in different settings.
\item
  \textbf{Errors may be correlated}. Same error may have multiple symptoms. Addressing one symptom without addressing the error, results in more symptoms.
\item
  \textbf{Fixing an error may introduce new errors}. Your subsequent code may be dependent on the line with the error.
\end{itemize}

\hypertarget{debugging-strategies-in-general}{%
\section{Debugging Strategies In General}\label{debugging-strategies-in-general}}

What to do when a bug is suspected:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Find where the bug is.
\item
  Determine what the bug is.
\item
  Fix the bug.
\end{enumerate}

Finding the bug is often the hardest step.

Strategies to find a bug that do not require any addition functions or code.

\begin{itemize}
\item
  \textbf{Back Tracking/Bottom-Up}: Walk through your program from the last item you created and work your way back up to the top. Observe each point in the program and see which points are not working correctly, and stop when the program is working correctly. This is a good strategy for long chunks of code it is known or clear that most of it is working correctly.
\item
  \textbf{Incremental/Top-down development}: In this method we walk through each line of code, and check each step from ``the top down''. Only moving forward to subsequent steps once it is insured that the current steps is operating appropriately.
\item
  \textbf{Problem simplification}: Isolate the location where you suspect a problem. Simplify this section of code as much as possible and try test cases to reproduce the problem. This is a good method in general to try.
\item
  \textbf{Series of Print Statements}: Put a series of print statement in the program to make sure that the code is doing what you suspect at various locations.
\item
  \textbf{``Wolf fence'' algorithm/Binary Search}: Put a print statement in the middle of the code with a custom message. If the code runs and prints the statement, then it is likely your error is in the bottom 50\% of your code. If the print statement never gets printed, then it is likely your problem is in the top half. If you conclude that the error is in the bottom half then add another print statment that seperates the bottom 25\% of your code, from the top 75\% of your code. If this print statement is not present, then you can conlude that the problem is most likely between the bottom 50\% -75\% of your code. You can keep adding print statements further splitting the data in halfs in order to isolate the problem further. This method is helpful for determining where the problem is.
\end{itemize}

\hypertarget{example-of-the-binary-search-algorithm}{%
\subsection{Example of the Binary Search Algorithm}\label{example-of-the-binary-search-algorithm}}

Below is an example of the binary search algorithm. For this example, one of the lines of code in the \texttt{LongComplexFunction()} will generate an error. We will pretend that we do not know where the error is.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SimpleFun_Plus =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y) \{}
\NormalTok{    y =}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\DecValTok{1}
    \KeywordTok{return}\NormalTok{(y)}
\NormalTok{\}}
\NormalTok{SimpleFun_Minus =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y) \{}
\NormalTok{    y =}\StringTok{ }\NormalTok{y }\OperatorTok{-}\StringTok{ }\DecValTok{1}
    \KeywordTok{return}\NormalTok{(y)}
\NormalTok{\}}
\NormalTok{SimpleFun_A <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y) \{}
\NormalTok{    y =}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ "a"}
    \KeywordTok{return}\NormalTok{(y)}
\NormalTok{\}}



\CommentTok{# Hypothetical long complicated function}
\NormalTok{LongComplexFunction =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_A}\NormalTok{(x)  }\CommentTok{# The Problem }
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\CommentTok{# Function call produces an error}
\KeywordTok{LongComplexFunction}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The first step is to add a print statement half way through the program of function that is producing the error message. Then we call the function again and see if it produces the print statement before the error is generated.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LongComplexFunction =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}

    \KeywordTok{print}\NormalTok{(}\StringTok{"50%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_A}\NormalTok{(x)  }\CommentTok{# The Problem }
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\CommentTok{# Call the function again}
\KeywordTok{LongComplexFunction}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The print statement was produced, so we conclude that the top 50\% of the code was likely fine and focus on the bottom half. We add another print statement that splits the end of the function in half.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LongComplexFunction =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}

    \KeywordTok{print}\NormalTok{(}\StringTok{"50%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}

    \KeywordTok{print}\NormalTok{(}\StringTok{"75%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_A}\NormalTok{(x)  }\CommentTok{# The Problem }
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\CommentTok{# Call the function again}
\KeywordTok{LongComplexFunction}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Again the print statement was produced, so we conclude that the top 75\% of the code was likely fine and focus on the bottom 25\%. We can add another print statement that splits this portion in half.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LongComplexFunction =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}

    \KeywordTok{print}\NormalTok{(}\StringTok{"50%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Plus}\NormalTok{(x)}
\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}

    \KeywordTok{print}\NormalTok{(}\StringTok{"75%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_A}\NormalTok{(x)  }\CommentTok{# The Problem }

    \KeywordTok{print}\NormalTok{(}\StringTok{"90%-ish through the function"}\NormalTok{)}

\NormalTok{    x =}\StringTok{ }\KeywordTok{SimpleFun_Minus}\NormalTok{(x)}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\CommentTok{# Call the function again}
\KeywordTok{LongComplexFunction}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The last print statement was not produced before the error was generated, we have isolated a section of the function for where to look for the error.

\hypertarget{using-debuggers}{%
\section{Using Debuggers}\label{using-debuggers}}

Some popular debuggers in R:

\begin{itemize}
\tightlist
\item
  \texttt{traceback()}
\item
  \texttt{browser()}
\item
  \texttt{debug()}
\end{itemize}

\hypertarget{traceback}{%
\subsection{traceback()}\label{traceback}}

The \texttt{traceback()} function is useful to see where a error occurred within a function and when we call functions within functions. It is not particularly helpful for functions that are self-contained. It prints the sequence of calls that lead to the error. It is useful when an error occurs with an unidentifiable error message, or a large series of error messages is produced after calling a function.

\hypertarget{example-with-traceback}{%
\subsection*{Example with traceback()}\label{example-with-traceback}}
\addcontentsline{toc}{subsection}{Example with traceback()}

Run the following chunk of code and observe the output in your console. The command \texttt{func1(7)} results in an error, but we will pretend we do not know where the error occurred.
We type \texttt{traceback()} in the console to see where this error happened, and what the last function call was.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{func1 =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
    \KeywordTok{func2}\NormalTok{(x)}
\NormalTok{\}}
\NormalTok{func2 =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
    \KeywordTok{func3}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{\}}
\NormalTok{func3 =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
    \KeywordTok{func4}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{4}\NormalTok{)}
\NormalTok{\}}
\NormalTok{func4 =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    y =}\StringTok{ "a"}
\NormalTok{    x =}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\KeywordTok{func1}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\KeywordTok{traceback}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The function \texttt{traceback()} tells us that the last function called was \texttt{func4(x\ +\ 4)}, so we conclude that the error must be in that function.

\hypertarget{unfamiliar-function-with-traceback}{%
\subsection*{Unfamiliar function with traceback()}\label{unfamiliar-function-with-traceback}}
\addcontentsline{toc}{subsection}{Unfamiliar function with traceback()}

\hypertarget{browswer}{%
\subsection{browswer()}\label{browswer}}

\hypertarget{debug}{%
\subsection{debug()}\label{debug}}

\hypertarget{more-options-to-consider}{%
\section{More options to consider}\label{more-options-to-consider}}

R has even more functions and tools to help us ``examine'' the program to ``diagnose'' the problem. Here are some other features that can be explored.

\begin{itemize}
\tightlist
\item
  \texttt{Breakpoints}
\item
  \texttt{trace()}
\item
  \texttt{recover()}
\item
  \texttt{system.time()}
\end{itemize}

\hypertarget{important-takeaways}{%
\section{Important Takeaways}\label{important-takeaways}}

Debugging can take longer then writing the program itself.

\begin{itemize}
\item
  \textbf{Primary Goal}: Do not have bugs in the first place.
\item
  \textbf{Secondary Goal}: Have clean readable code where it is easy to spot the bugs quickly.
\end{itemize}

\emph{Great programmers are just good programmers with great habits.}

\hypertarget{tips-for-writing-good-code}{%
\subsection*{Tips for Writing good code}\label{tips-for-writing-good-code}}
\addcontentsline{toc}{subsection}{Tips for Writing good code}

10 Tips for Writing good code.

\begin{itemize}
\item
  \textbf{Use Descriptive Names}: Have a system for naming variables, functions, etc.
\item
  \textbf{Give Each Class/Function One Purpose}: Which is easier to edit, a function that is several hundred lines long? Or several small functions?
\item
  \textbf{Delete Unnecessary Code}: If you comment out a chunk of code that you are no longer using, delete it!
\item
  \textbf{Readability \(>\) Cleverness}: Compacting 10 lines of code sounds appealing, and is likely clever, but it is even more likely to be difficult to read.
\item
  \textbf{Keep a Consistent Coding Style}: Have a formatting method? Stick to it.
\item
  \textbf{Choose the right program}: You do not need to have the best program, but you will want a program where your project is all in the same place.
\item
  \textbf{Master the Language's Idioms}: If the language has a system and syntax it was built to use, use it. (R and vectorization, Python and lists, C and defining variable types)
\item
  \textbf{Study the Code of Others}: Read code from experts and novice. Get a feel for what makes clean code.
\item
  \textbf{Write Good Comments}: Comments exist to explain WHY a piece of code exists rather than WHAT the code actually does. (i.e.~``Use because X, Y, and Z'', not ``This will do W, U, and V.''). Use more rather than less, but too many is problematic.
\item
  \textbf{Refactor/Rewrite}: Just because the program works, doesn't mean it can be adjusted to be more clear. Refactor as you would rewrite an essay.
\end{itemize}

\hypertarget{steps-to-reduce-the-number-of-bugs}{%
\subsection*{Steps to Reduce the Number of Bugs}\label{steps-to-reduce-the-number-of-bugs}}
\addcontentsline{toc}{subsection}{Steps to Reduce the Number of Bugs}

The most important way to combat bugs is to write a bug-free program in the first place.

\begin{itemize}
\item
  Write your program in such a way that it can stand alone, and be understood by a peer with a similar level of programming knowledge.
\item
  Sit and make a plan for your program before you begin writing it.
\item
  Avoid writing the program as fast as possible.
\item
  Practice defensive programming. This is similar to defensive driving, which means driving under worst-case scenarios. Make your code explicit, have your program print out an error message or make checks for the input.
\end{itemize}

\hypertarget{after-you-located-the-error}{%
\subsection*{After You Located the Error}\label{after-you-located-the-error}}
\addcontentsline{toc}{subsection}{After You Located the Error}

Often the hardest step is locating \emph{where} the bug is. The next step is determining \emph{what} the bug is.

\begin{itemize}
\item
  Help Files
\item
  Google (seriously)
\end{itemize}

\hypertarget{resources}{%
\section{Resources}\label{resources}}

\begin{itemize}
\item
  \url{http://www.cs.cornell.edu/courses/cs312/2006fa/lectures/lec26.html}
\item
  \url{https://en.wikipedia.org/wiki/Debugging}
\item
  \url{https://data-flair.training/blogs/debugging-in-r-programming/}
\item
  \url{https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio}
\item
  \url{https://adv-r.hadley.nz/debugging.html}
\item
  \url{http://www.math.ncu.edu.tw/~chenwc/R/_note/reference/debug/Rdebug.pdf}
\item
  \url{https://www.makeuseof.com/tag/10-tips-writing-cleaner-better-code/}
\item
  \url{https://owi.usgs.gov/R/training-curriculum/r-package-dev/debugging/}
\end{itemize}

  \bibliography{book.bib,packages.bib}

\end{document}
